// src/lib/bass-synth-manager.ts
import type { FractalEvent } from '@/types/fractal';

export class BassSynthManager {
  private ctx: AudioContext;
  private worklet: AudioWorkletNode;
  private presetParams: Record<string, number> = {};

  constructor(ctx: AudioContext) {
    this.ctx = ctx;
    this.worklet = new AudioWorkletNode(ctx, 'bass-processor');
  }

  async init() {
    await this.ctx.audioWorklet.addModule('/worklets/bass-processor.js');
    this.worklet.connect(this.ctx.destination);
  }

  public play(event: FractalEvent) {
    const freq = 440 * Math.pow(2, (event.note - 69) / 12);
    const velocity = event.dynamics === 'p' ? 0.3 : event.dynamics === 'mf' ? 0.6 : 0.9;

    // Настройка параметров под технику
    const params = this.getParamsForTechnique(event.technique, event.phrasing);
    Object.entries(params).forEach(([key, value]) => {
      if (this.worklet.parameters.has(key)) {
        this.worklet.parameters.get(key)!.setValueAtTime(value, this.ctx.currentTime);
      }
    });

    // Отправка ноты
    this.worklet.port.postMessage({ type: 'noteOn', frequency: freq, velocity });
    
    // Авто-стоп через duration
    setTimeout(() => {
      this.worklet.port.postMessage({ type: 'noteOff' });
    }, event.duration * 1000);
  }

  private getParamsForTechnique(technique: string, phrasing: string) {
    switch (technique) {
      case 'ghost':
        return { cutoff: 250, resonance: 0.3, distortion: 0.01, portamento: 0.0 };
      case 'slap':
        return { cutoff: 350, resonance: 0.8, distortion: 0.15, portamento: 0.0 };
      case 'pluck':
        return { 
          cutoff: 400, 
          resonance: 0.6, 
          distortion: 0.05, 
          portamento: phrasing === 'legato' ? 0.03 : 0.0 
        };
      default:
        return { cutoff: 400, resonance: 0.6, distortion: 0.05, portamento: 0.0 };
    }
  }

  public connect(destination: AudioNode) {
    this.worklet.connect(destination);
  }
}