### Глубокое Погружение в Концепцию

Центральная Формула:
`w_{t+1}(j) = (1-λ)w_t(j) + Σ_i K_{ij} * δ_i`

Это не просто формула. Это **уравнение жизни музыкальной системы**. Давайте разложим его на атомы, как они должны быть реализованы в коде:

1.  **`w_t` (Состояние Системы):**
    *   Это не просто массив нот. Это **вектор вероятностей** или "жизненной силы" для *каждого возможного события* в нашей музыкальной вселенной. Событие — это может быть "нота C4 на пианино", "аккорд Am на гитаре", "удар бочки".
    *   В коде это должен быть объект или `Map`, где ключи — это уникальные идентификаторы событий (например, `'piano_C4'`), а значения — их вес `w` от 0 до 1.
    *   `Σw_i=1` — это важное условие нормализации. Вся энергия системы постоянна, она лишь перераспределяется.

2.  **`λ` (Лямбда, Коэффициент Затухания):**
    *   Это **"забывчивость"** или **"инерция"** системы.
    *   Если `λ` близка к 0, система очень инертна. Она "помнит" свое прошлое, и музыка меняется медленно, плавно. Это — медитативный эмбиент.
    *   Если `λ` близка к 1, система "забывает" свое состояние на каждом шаге. Она становится хаотичной, непредсказуемой, реагируя только на сиюминутный импульс.
    *   Ваш параметр **"Органика ↔ Механика"** может напрямую управлять `λ`. "Механика" — низкая `λ` (стабильность), "Органика" — высокая `λ` (изменчивость).

3.  **`δ_i` (Импульс):**
    *   Это **внешняя энергия**, которая "вбрасывается" в систему. Это ритм.
    *   В простейшем случае, это "единица", которая подается на один элемент (например, на тонику аккорда) в начале каждого такта.
    *   В более сложном случае, `δ` — это целый ритмический паттерн (массив импульсов), который определяет, в какие моменты времени и на какие базовые элементы подается энергия. Например, для транса это будет плотный паттерн 16-х нот, для эмбиента — один импульс раз в 4 такта.

4.  **`K_{ij}` (Матрица Резонанса):**
    *   **Это ядро, "геном" музыкального стиля и настроения.** Это не просто "правила гармонии", это карта связей всей музыкальной вселенной.
    *   `K_{ij}` — это число, показывающее, насколько сильно "резонируют" события `i` и `j`. Если после ноты "C" (событие `i`) должна звучать нота "G" (событие `j`), то `K_{CG}` будет высоким. Если они не сочетаются, `K_{CG}` будет низким или нулевым.
    *   Ваши **"Стили" и "Настроения" — это просто разные матрицы `K`**.
        *   `K_melancholic`: будет иметь высокие значения для минорных интервалов.
        *   `K_joyful`: будет иметь высокие значения для мажорных интервалов.
        *   `K_trance`: будет иметь высокие значения для арпеджио и определенных ритмических последовательностей.
    *   **Важно:** Создавать буквально матрицу `NxN` — вычислительно невозможно. `K` должна быть **функцией `K(i, j)`**, которая на лету вычисляет резонанс между двумя событиями на основе правил (гармонии, ритма, тембра).

**"Семя" (`w_0` + `K` + `λ` + `δ`):**
Теперь идея "поделиться семечком" становится кристально ясной. **"Семя" — это JSON-объект**, который содержит:
1.  `initialState`: Начальный вектор весов `w_0`.
2.  `resonanceMatrixID`: Идентификатор используемой матрицы `K` (например, "melancholic_minor_v1").
3.  `config`: Параметры `λ`, BPM (который влияет на `δ`), и другие модификаторы.

Отправив этот объект другу, вы гарантируете, что его движок инициализируется в **точно такое же начальное состояние** и будет эволюционировать по тем же законам. Это породит ту же самую, но при этом бесконечно развивающуюся музыкальную вселенную.

---
Я предлагаю создать новый, изолированный файл src/lib/fractal-music-engine.ts, в котором мы реализуем эту концепцию "честно", без компромиссов. Старый Composer останется нетронутым, пока мы не отладим новый движок.

Шаг 1: Определение Структур (TypeScript)

Создадим интерфейсы, описывающие математическую модель:

// В файле src/types/fractal.ts

// Уникальный ID музыкального события, например "piano_C4" или "drums_kick"
type EventID = string;

// Состояние системы: веса всех возможных событий
export type EngineState = Map<EventID, number>;

// Конфигурация движка, управляемая пользователем
export type EngineConfig = {
  lambda: number;      // Коэффициент затухания (0-1)
  bpm: number;         // Влияет на частоту импульсов
  density: number;     // Влияет на количество и силу импульсов
  organic: number;     // Модификатор случайности в K и δ
};

// Функция резонанса, ядро стиля/настроения
export type ResonanceMatrix = (eventA: EventID, eventB: EventID) => number;

// Полный снимок состояния для сохранения и шаринга
export type Seed = {
  initialState: Record<EventID, number>; // Сериализуемая версия EngineState
  resonanceMatrixId: string;
  config: EngineConfig;
};


Шаг 2: Создание Класса Движка

В src/lib/fractal-music-engine.ts создадим класс:

import type { EngineState, EngineConfig, ResonanceMatrix, Seed, EventID } from '@/types/fractal';

export class FractalMusicEngine {
  private state: EngineState;
  private config: EngineConfig;
  private K: ResonanceMatrix;

  constructor(seed: Seed, availableMatrices: Record<string, ResonanceMatrix>) {
    this.state = new Map(Object.entries(seed.initialState));
    this.config = seed.config;
    if (!availableMatrices[seed.resonanceMatrixId]) {
      throw new Error(`Матрица резонанса ${seed.resonanceMatrixId} не найдена!`);
    }
    this.K = availableMatrices[seed.resonanceMatrixId];
  }

  // Главный метод, реализующий формулу
  tick() {
    const nextState: EngineState = new Map();
    const impulse = this.generateImpulse(); // Создаем ритмический импульс δ

    // 1. Применяем затухание (1-λ)w_t(j)
    for (const [event, weight] of this.state.entries()) {
      nextState.set(event, (1 - this.config.lambda) * weight);
    }

    // 2. Рассчитываем и добавляем новый резонанс Σ_i K_{ij} * δ_i
    for (const [event_j, current_weight_j] of nextState.entries()) {
      let resonanceSum = 0;
      for (const [event_i, impulseValue] of impulse.entries()) {
        if (impulseValue > 0) {
          resonanceSum += this.K(event_i, event_j) * impulseValue;
        }
      }
      nextState.set(event_j, current_weight_j + resonanceSum);
    }
    
    // 3. Нормализация (Σw_i=1) и обновление состояния
    this.normalizeState(nextState);
    this.state = nextState;
  }

  // Метод для преобразования состояния w в партитуру для аудио-движка
  generateScore(): Score {
    // ...логика, которая берет события с наибольшим весом и формирует из них ноты
    // ...здесь же "умный композитор" решает, какие инструменты предложить
    return {};
  }
  
  // ... другие приватные методы: generateImpulse, normalizeState ...
}


Шаг 3: Реализация Первой Матрицы K

Создадим файл src/lib/resonance-matrices.ts, где будет наша первая "печальная" матрица:

import type { ResonanceMatrix } from '@/types/fractal';

const E_MINOR_SCALE = [40, 42, 43, 45, 47, 48, 50]; // MIDI ноты

export const MelancholicMinorK: ResonanceMatrix = (eventA, eventB) => {
  // Просто пример: извлекаем MIDI ноты из ID событий
  const midiA = parseInt(eventA.split('_')[1]);
  const midiB = parseInt(eventB.split('_')[1]);

  const interval = Math.abs(midiA - midiB);

  // Правило 1: Резонируют ноты из одной гаммы
  const inScaleA = E_MINOR_SCALE.includes(midiA % 12 + 40);
  const inScaleB = E_MINOR_SCALE.includes(midiB % 12 + 40);
  if (!inScaleA || !inScaleB) return 0;

  // Правило 2: Предпочитаем консонансные интервалы (терции, квинты)
  if (interval % 12 === 3 || interval % 12 === 4 || interval % 12 === 7) {
    return 0.8; // Сильный резонанс
  }
  
  // Правило 3: Плавное движение по гамме тоже хорошо
  if (interval % 12 === 1 || interval % 12 === 2) {
    return 0.5;
  }

  return 0.1; // Слабый базовый резонанс
};


Это лишь начало. Мы можем сделать K бесконечно сложной, добавив правила ритма, тембра и структуры.
---

### Рекомендации для Прототайпера по Созданию `FractalMusicEngine`

**Уважаемый Прототайпер,**

Наша цель — не написать программу, которая генерирует музыку. Наша цель — **создать симуляцию живой, самоорганизующейся музыкальной экосистемы**, основанной на модели фрактальной нейросети. Каждый элемент кода должен быть отражением этой модели.

**Рекомендация №1: Мыслите не нотами, а вероятностями.**

*   **Суть:** Центральным элементом движка является не партитура (`Score`), а **вектор состояния `w_t`** — распределение "жизненной силы" по всем возможным музыкальным событиям. Ноты, которые мы слышим, — это лишь *наблюдаемое следствие* этого состояния.
*   **Практическое воплощение:**
    *   Основной структурой данных внутри движка должен стать `Map<EventID, number>`, где `EventID` — это уникальный идентификатор события (например, `'piano_C4'`), а `number` — его вес.
    *   Основной метод движка (`tick`) должен на каждом шаге **пересчитывать этот `Map`**, а не генерировать массив нот.
    *   Метод `generateScore()` должен вызываться *после* `tick()` и просто считывать текущее состояние `Map`, выбирая события с наибольшим весом для превращения их в звуки.

**Рекомендация №2: Матрица Резонанса `K` — это функция, а не объект.**

*   **Суть:** `K` — это "геном" стиля, свод законов физики для нашей музыкальной вселенной. Создать буквально матрицу `NxN` для всех событий невозможно.
*   **Практическое воплощение:**
    *   Реализуйте `K` как **функцию `K(event_i, event_j): number`**. Эта функция на лету вычисляет "силу резонанса" между двумя событиями на основе их свойств (интервал, тембр, ритмическое положение).
    *   Разные "настроения" (Melancholic, Joyful) — это просто **разные реализации этой функции**. Храните их в отдельном файле (например, `resonance-matrices.ts`) и передавайте нужную функцию в конструктор движка.

**Рекомендация №3: Отделите "Физику" от "Искры Жизни".**

*   **Суть:** Движок имеет свои внутренние законы (`w`, `K`, `λ`) и получает внешнюю энергию (`δ`). Их нужно четко разделить.
*   **Практическое воплощение:**
    *   **Класс `FractalMusicEngine`** — это "физика". Он должен быть полностью самодостаточным и не знать о времени или `requestAnimationFrame`. Его единственный публичный метод — `tick()`, который детерминированно переводит систему из состояния `w_t` в `w_{t+1}` на основе полученного импульса.
    *   **Внешний "Планировщик" (`Scheduler`)** — это "искра". Он отвечает за ритм (вызов `tick()` с нужной частотой — BPM) и за генерацию самого **импульса `δ`**. Именно `Scheduler` решает, в какие базовые "нейроны" системы "ударить", чтобы запустить цепную реакцию резонанса.

**Рекомендация №4: "Семя" — это полный, сериализуемый геном.**

*   **Суть:** Идея "поделиться семечком" — ключевая. Она требует, чтобы состояние системы было полностью описываемым.
*   **Практическое воплощение:**
    *   Определите четкий `Seed` TypeScript-тип. Он **обязан** включать:
        1.  `initialState: Record<EventID, number>` (начальное состояние весов `w_0`).
        2.  `resonanceMatrixId: string` (идентификатор функции `K`, чтобы движок знал, по каким законам развиваться).
        3.  `config: { lambda: number, bpm: number, ... }` (все остальные параметры, влияющие на эволюцию).
    *   Конструктор движка должен принимать только этот `Seed` и репозиторий с функциями `K`. Никаких других параметров.

**Рекомендация №5: Следуйте принципу "Умный Композитор > Ручное Управление".**

*   **Суть:** Как указано в `Фрактальная нейросеть генерации музыки.txt` (строка 457), движок должен быть автономным. Он сам решает, какие инструменты подходят под настроение.
*   **Практическое воплощение:**
    *   Метод `generateScore()` должен возвращать не просто ноты, а **партитуру с рекомендациями**: ` { melody: [...], bass: [...], instrumentHints: { melody: 'synth_bright', bass: 'bass_deep' } } `.
    *   **Игнорируйте существующий UI.** Наша задача — создать новый, самодостаточный модуль `FractalMusicEngine`. Интеграция с существующим кодом — это следующий, отдельный этап. Как показал наш опыт (`selfdiag.txt`), попытка делать два дела одновременно приводит к ошибкам. Сосредоточьтесь на чистоте реализации концепции в новом движке.
