// ═══════════════════════════════════════════════════════════════════════════
// INSTRUMENT FACTORY v3.0
// Полная реализация: synth, organ, bass, guitar
// ═══════════════════════════════════════════════════════════════════════════

// ───── HELPERS ─────

const midiToHz = (m: number) => 440 * Math.pow(2, (m - 69) / 12);
const dB = (x: number) => Math.pow(10, x / 20);
const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));

const loadIR = async (ctx: AudioContext, url: string | null): Promise<AudioBuffer | null> => {
    if (!url) return null;
    try {
        const res = await fetch(url);
        if (!res.ok) return null;
        const buf = await res.arrayBuffer();
        return await ctx.decodeAudioData(buf);
    } catch {
        console.warn(`[Factory] Could not load IR: ${url}`);
        return null;
    }
};

// ───── DISTORTION CURVES ─────

const makeSoftClip = (amount = 0.5, n = 8192) => {
    const c = new Float32Array(n);
    const k = clamp(amount, 0, 1) * 10 + 1;
    const norm = Math.tanh(k);
    for (let i = 0; i < n; i++) {
        const x = (i / (n - 1)) * 2 - 1;
        c[i] = Math.tanh(k * x) / norm;
    }
    return c;
};

const makeMuff = (gain = 0.65, n = 8192) => {
    const c = new Float32Array(n);
    const k = 1 + clamp(gain, 0, 1) * 4;
    for (let i = 0; i < n; i++) {
        const x = (i / (n - 1)) * 2 - 1;
        c[i] = Math.tanh(x * k) * 0.9;
    }
    return c;
};

const makeTubeSaturation = (drive = 0.3, n = 8192) => {
    const curve = new Float32Array(n);
    const k = drive * 5 + 1;
    for (let i = 0; i < n; i++) {
        const x = (i / (n - 1)) * 2 - 1;
        curve[i] = x >= 0 ? Math.tanh(k * x) : Math.tanh(k * x * 0.8) * 0.9;
    }
    return curve;
};

// ───── SIMPLE FX FACTORIES ─────

interface SimpleFX {
    input: GainNode;
    output: GainNode;
    setMix: (m: number) => void;
}

const makeChorus = (ctx: AudioContext, rate = 0.3, depth = 0.004, mix = 0.3): SimpleFX => {
    const input = ctx.createGain();
    const output = ctx.createGain();
    const dry = ctx.createGain(); dry.gain.value = 1;
    const wet = ctx.createGain(); wet.gain.value = mix;
    
    const delay = ctx.createDelay(0.05);
    delay.delayTime.value = 0.015;
    
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = rate;
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = depth;
    lfo.connect(lfoGain).connect(delay.delayTime);
    lfo.start();
    
    input.connect(dry).connect(output);
    input.connect(delay).connect(wet).connect(output);
    
    return {
        input, output,
        setMix: (m) => {
            wet.gain.value = clamp(m, 0, 1);
        }
    };
};

const makeDelay = (ctx: AudioContext, time = 0.3, fb = 0.25, hc = 3000, mix = 0.2): SimpleFX => {
    const input = ctx.createGain();
    const output = ctx.createGain();
    const dry = ctx.createGain(); dry.gain.value = 1;
    const wet = ctx.createGain(); wet.gain.value = mix;
    
    const delayNode = ctx.createDelay(2);
    delayNode.delayTime.value = time;
    
    const feedback = ctx.createGain();
    feedback.gain.value = fb;
    
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = hc;
    
    input.connect(dry).connect(output);
    input.connect(delayNode).connect(filter).connect(feedback).connect(delayNode);
    filter.connect(wet).connect(output);
    
    return {
        input, output,
        setMix: (m) => {
            wet.gain.value = clamp(m, 0, 1);
        }
    };
};

// ───── ADSR HELPER ─────

interface VoiceGain {
    node: GainNode;
    startTime: number;
}

const triggerAttack = (
    ctx: AudioContext,
    gain: GainNode,
    when: number,
    a: number, d: number, s: number,
    velocity = 1
): VoiceGain => {
    const attack = Math.max(a, 0.003);
    const decay = Math.max(d, 0.01);
    const sustain = clamp(s, 0, 1) * velocity;
    
    gain.gain.cancelScheduledValues(when);
    gain.gain.setValueAtTime(0.0001, when);
    gain.gain.linearRampToValueAtTime(velocity, when + attack);
    gain.gain.setTargetAtTime(sustain, when + attack, decay / 3);
    
    return { node: gain, startTime: when };
};

const triggerRelease = (
    ctx: AudioContext,
    voiceGain: VoiceGain,
    when: number,
    a: number, r: number
): number => {
    const release = Math.max(r, 0.02);
    const elapsed = when - voiceGain.startTime;
    
    voiceGain.node.gain.cancelScheduledValues(when);
    
    if (elapsed < a) {
        // Ещё в атаке — быстрый release
        const current = voiceGain.node.gain.value;
        voiceGain.node.gain.setValueAtTime(current, when);
        voiceGain.node.gain.linearRampToValueAtTime(0.0001, when + 0.05);
        return when + 0.05;
    } else {
        voiceGain.node.gain.setValueAtTime(voiceGain.node.gain.value, when);
        voiceGain.node.gain.setTargetAtTime(0.0001, when, release / 3);
        return when + release;
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// INSTRUMENT API INTERFACE
// ═══════════════════════════════════════════════════════════════════════════

export interface InstrumentAPI {
    connect: (dest?: AudioNode) => void;
    disconnect: () => void;
    noteOn: (midi: number, when?: number, velocity?: number) => void;
    noteOff: (midi: number, when?: number) => void;
    allNotesOff: () => void;
    setPreset: (p: any) => void;
    setParam: (k: string, v: any) => void;
    setVolume: (level: number) => void;
    getVolume: () => number;
    setExpression: (level: number) => void;
    preset: any;
    type: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// SYNTH ENGINE
// ═══════════════════════════════════════════════════════════════════════════

const buildSynthEngine = (
    ctx: AudioContext,
    preset: any,
    master: GainNode,
    reverb: ConvolverNode,
    instrumentGain: GainNode,
    expressionGain: GainNode
): Partial<InstrumentAPI> => {
    
    let currentPreset = { ...preset };
    
    // Static FX chain
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = currentPreset.comp?.threshold ?? -18;
    comp.ratio.value = currentPreset.comp?.ratio ?? 4;
    comp.attack.value = 0.003;
    comp.release.value = 0.15;
    
    const compMakeup = ctx.createGain();
    compMakeup.gain.value = dB(currentPreset.comp?.makeup ?? 6);
    
    const filt1 = ctx.createBiquadFilter();
    filt1.type = 'lowpass';
    filt1.frequency.value = currentPreset.lpf?.cutoff ?? 2000;
    filt1.Q.value = currentPreset.lpf?.q ?? 1;
    
    const filt2 = ctx.createBiquadFilter();
    filt2.type = 'lowpass';
    filt2.frequency.value = currentPreset.lpf?.cutoff ?? 2000;
    filt2.Q.value = currentPreset.lpf?.q ?? 1;
    
    const use24dB = currentPreset.lpf?.mode === '24dB';
    
    const chorus = makeChorus(ctx, 
        currentPreset.chorus?.rate ?? 0.3,
        currentPreset.chorus?.depth ?? 0.004,
        currentPreset.chorus?.on ? (currentPreset.chorus?.mix ?? 0.3) : 0
    );
    
    const delay = makeDelay(ctx,
        currentPreset.delay?.time ?? 0.35,
        currentPreset.delay?.fb ?? 0.25,
        currentPreset.delay?.hc ?? 3000,
        currentPreset.delay?.on ? (currentPreset.delay?.mix ?? 0.2) : 0
    );
    
    const revSend = ctx.createGain();
    revSend.gain.value = currentPreset.reverbMix ?? 0.18;
    
    // Routing
    comp.connect(compMakeup);
    compMakeup.connect(filt1);
    
    if (use24dB) {
        filt1.connect(filt2);
        filt2.connect(chorus.input);
    } else {
        filt1.connect(chorus.input);
    }
    
    chorus.output.connect(delay.input);
    delay.output.connect(expressionGain);
    expressionGain.connect(instrumentGain);
    instrumentGain.connect(master);
    
    delay.output.connect(revSend);
    revSend.connect(reverb);
    
    // LFO for filter modulation
    let lfo: OscillatorNode | null = null;
    let lfoGain: GainNode | null = null;
    
    if (currentPreset.lfo?.amount > 0 && currentPreset.lfo?.target === 'filter') {
        lfo = ctx.createOscillator();
        lfo.type = (currentPreset.lfo?.shape as OscillatorType) || 'sine';
        lfo.frequency.value = currentPreset.lfo?.rate ?? 1;
        lfoGain = ctx.createGain();
        lfoGain.gain.value = currentPreset.lfo?.amount ?? 0;
        lfo.connect(lfoGain);
        lfoGain.connect(filt1.frequency);
        if (use24dB) lfoGain.connect(filt2.frequency);
        lfo.start();
    }
    
    // Voice management
    interface SynthVoice {
        oscs: OscillatorNode[];
        gains: GainNode[];
        noise?: AudioBufferSourceNode;
        voiceGain: GainNode;
        voiceState: VoiceGain;
    }
    
    const activeVoices = new Map<number, SynthVoice>();
    let noiseBuffer: AudioBuffer | null = null;
    
    if (currentPreset.noise?.on) {
        noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
        const d = noiseBuffer.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
    }
    
    const getOscConfig = () => {
        if (currentPreset.osc && currentPreset.osc.length > 0) return currentPreset.osc;
        return [{ type: 'sawtooth', gain: 0.5, octave: 0, detune: 0 }];
    };
    
    const noteOn = (midi: number, when = ctx.currentTime, velocity = 1.0) => {
        if (activeVoices.has(midi)) {
            noteOff(midi, when);
        }
        
        const f = midiToHz(midi);
        const vel = clamp(velocity, 0, 1);
        
        // ВАЖНО: Каждая нота получает СВОЙ voiceGain!
        const voiceGain = ctx.createGain();
        voiceGain.gain.value = 0;
        voiceGain.connect(comp); // Подключаем к статической цепи
        
        const oscConfig = getOscConfig();
        const oscs: OscillatorNode[] = [];
        const gains: GainNode[] = [];
        
        for (const o of oscConfig) {
            const osc = ctx.createOscillator();
            osc.type = (o.type as OscillatorType) || 'sawtooth';
            
            const octave = o.octave || 0;
            const detune = o.detune || 0;
            osc.frequency.value = f * Math.pow(2, octave);
            osc.detune.value = detune;
            
            const g = ctx.createGain();
            g.gain.value = (o.gain ?? 0.5) * vel;
            
            osc.connect(g);
            g.connect(voiceGain);
            osc.start(when);
            
            oscs.push(osc);
            gains.push(g);
        }
        
        // Noise
        let noise: AudioBufferSourceNode | undefined;
        if (currentPreset.noise?.on && noiseBuffer) {
            noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            noise.loop = true;
            const ng = ctx.createGain();
            ng.gain.value = (currentPreset.noise.gain ?? 0.1) * vel;
            noise.connect(ng);
            ng.connect(voiceGain);
            noise.start(when);
        }
        
        const adsr = currentPreset.adsr || { a: 0.01, d: 0.2, s: 0.7, r: 0.3 };
        const voiceState = triggerAttack(ctx, voiceGain, when, adsr.a, adsr.d, adsr.s, vel);
        
        activeVoices.set(midi, { oscs, gains, noise, voiceGain, voiceState });
    };
    
    const noteOff = (midi: number, when = ctx.currentTime) => {
        const voice = activeVoices.get(midi);
        if (!voice) return;
        
        const adsr = currentPreset.adsr || { a: 0.01, d: 0.2, s: 0.7, r: 0.3 };
        const stopTime = triggerRelease(ctx, voice.voiceState, when, adsr.a, adsr.r);
        
        voice.oscs.forEach(osc => osc.stop(stopTime + 0.1));
        if (voice.noise) voice.noise.stop(stopTime + 0.1);
        
        // Cleanup после release
        setTimeout(() => {
            try {
                voice.voiceGain.disconnect();
            } catch {}
        }, (stopTime - ctx.currentTime + 0.2) * 1000);
        
        activeVoices.delete(midi);
    };
    
    const allNotesOff = () => {
        activeVoices.forEach((_, midi) => noteOff(midi, ctx.currentTime));
    };
    
    const setPreset = (p: any) => {
        allNotesOff();
        currentPreset = { ...p };
        
        // Update static nodes
        filt1.frequency.value = p.lpf?.cutoff ?? 2000;
        filt1.Q.value = p.lpf?.q ?? 1;
        filt2.frequency.value = p.lpf?.cutoff ?? 2000;
        filt2.Q.value = p.lpf?.q ?? 1;
        
        comp.threshold.value = p.comp?.threshold ?? -18;
        comp.ratio.value = p.comp?.ratio ?? 4;
        compMakeup.gain.value = dB(p.comp?.makeup ?? 6);
        
        chorus.setMix(p.chorus?.on ? (p.chorus?.mix ?? 0.3) : 0);
        delay.setMix(p.delay?.on ? (p.delay?.mix ?? 0.2) : 0);
        revSend.gain.value = p.reverbMix ?? 0.18;
        
        if (p.volume !== undefined) {
            instrumentGain.gain.value = p.volume;
        }
        
        // Noise buffer
        if (p.noise?.on) {
            noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
            const d = noiseBuffer.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
        } else {
            noiseBuffer = null;
        }
    };
    
    const setParam = (k: string, v: any) => {
        if (k === 'filterCutoff') {
            filt1.frequency.setTargetAtTime(v, ctx.currentTime, 0.02);
            filt2.frequency.setTargetAtTime(v, ctx.currentTime, 0.02);
        }
        if (k === 'reverbMix') revSend.gain.value = v;
    };
    
    return { noteOn, noteOff, allNotesOff, setPreset, setParam };
};

// ═══════════════════════════════════════════════════════════════════════════
// ORGAN ENGINE
// ═══════════════════════════════════════════════════════════════════════════

const buildOrganEngine = (
    ctx: AudioContext,
    preset: any,
    master: GainNode,
    reverb: ConvolverNode,
    instrumentGain: GainNode,
    expressionGain: GainNode
): Partial<InstrumentAPI> => {
    
    let currentPreset = { ...preset };
    
    // Drawbar ratios: 16', 5⅓', 8', 4', 2⅔', 2', 1⅗', 1⅓', 1'
    const DRAWBAR_RATIOS = [0.5, 1.5, 1, 2, 3, 4, 5, 6, 8];
    
    // ─── Static chain ───
    
    // Leslie simulation
    const leslieInput = ctx.createGain();
    const leslieOutput = ctx.createGain();
    
    // Simple Leslie: chorus + tremolo
    const leslieDelay = ctx.createDelay(0.03);
    leslieDelay.delayTime.value = 0.003;
    
    const leslieLfo = ctx.createOscillator();
    leslieLfo.type = 'sine';
    leslieLfo.frequency.value = currentPreset.leslie?.slow ?? 0.7;
    const leslieLfoGain = ctx.createGain();
    leslieLfoGain.gain.value = 0.002;
    leslieLfo.connect(leslieLfoGain).connect(leslieDelay.delayTime);
    leslieLfo.start();
    
    const leslieTremolo = ctx.createGain();
    leslieTremolo.gain.value = 1;
    const tremoloLfo = ctx.createOscillator();
    tremoloLfo.type = 'sine';
    tremoloLfo.frequency.value = currentPreset.leslie?.slow ?? 0.7;
    const tremoloGain = ctx.createGain();
    tremoloGain.gain.value = 0.15;
    tremoloLfo.connect(tremoloGain).connect(leslieTremolo.gain);
    tremoloLfo.start();
    
    const leslieDry = ctx.createGain();
    leslieDry.gain.value = 0.5;
    const leslieWet = ctx.createGain();
    leslieWet.gain.value = 0.5;
    
    leslieInput.connect(leslieDry).connect(leslieOutput);
    leslieInput.connect(leslieDelay).connect(leslieTremolo).connect(leslieWet).connect(leslieOutput);
    
    // Filters
    const lpf = ctx.createBiquadFilter();
    lpf.type = 'lowpass';
    lpf.frequency.value = currentPreset.lpf ?? 3500;
    lpf.Q.value = 0.5;
    
    const hpf = ctx.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = currentPreset.hpf ?? 60;
    hpf.Q.value = 0.5;
    
    // Vibrato/Chorus
    const vibratoLfo = ctx.createOscillator();
    vibratoLfo.type = 'sine';
    vibratoLfo.frequency.value = currentPreset.vibratoRate ?? 6;
    const vibratoGain = ctx.createGain();
    vibratoGain.gain.value = (currentPreset.vibratoDepth ?? 0.003) * 100; // cents
    vibratoLfo.connect(vibratoGain);
    vibratoLfo.start();
    
    // Soft chorus для органа
    const organChorus = makeChorus(ctx, 0.5, 0.003, currentPreset.chorusMix ?? 0.2);
    
    const revSend = ctx.createGain();
    revSend.gain.value = currentPreset.reverbMix ?? 0.2;
    
    // Routing
    leslieOutput.connect(lpf);
    lpf.connect(hpf);
    hpf.connect(organChorus.input);
    organChorus.output.connect(expressionGain);
    expressionGain.connect(instrumentGain);
    instrumentGain.connect(master);
    
    organChorus.output.connect(revSend);
    revSend.connect(reverb);
    
    // Key click buffer
    const clickBuffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.008), ctx.sampleRate);
    const clickData = clickBuffer.getChannelData(0);
    for (let i = 0; i < clickData.length; i++) {
        clickData[i] = (Math.random() * 2 - 1) * Math.exp(-i * 0.001);
    }
    
    // Voice management
    interface OrganVoice {
        oscs: OscillatorNode[];
        gains: GainNode[];
        voiceGain: GainNode;
        voiceState: VoiceGain;
        click?: AudioBufferSourceNode;
    }
    
    const activeVoices = new Map<number, OrganVoice>();
    
    const noteOn = (midi: number, when = ctx.currentTime, velocity = 1.0) => {
        if (activeVoices.has(midi)) noteOff(midi, when);
        
        const f = midiToHz(midi);
        const vel = clamp(velocity, 0, 1);
        const drawbars = currentPreset.drawbars || [8, 8, 8, 0, 0, 0, 0, 0, 0];
        
        const voiceGain = ctx.createGain();
        voiceGain.gain.value = 0;
        voiceGain.connect(leslieInput);
        
        const oscs: OscillatorNode[] = [];
        const gains: GainNode[] = [];
        
        // Создаём осцилляторы для каждого ненулевого drawbar
        for (let i = 0; i < 9; i++) {
            const level = drawbars[i] || 0;
            if (level === 0) continue;
            
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = f * DRAWBAR_RATIOS[i];
            
            // Vibrato modulation
            vibratoGain.connect(osc.detune);
            
            const g = ctx.createGain();
            // Используем квадратичную шкалу для более натурального микса
            const levelNorm = level / 8;
            g.gain.value = levelNorm * levelNorm * 0.3 * vel;
            
            osc.connect(g);
            g.connect(voiceGain);
            osc.start(when);
            
            oscs.push(osc);
            gains.push(g);
        }
        
        // Key click
        let click: AudioBufferSourceNode | undefined;
        const clickLevel = currentPreset.keyClick ?? 0.003;
        if (clickLevel > 0 && vel > 0.2) {
            click = ctx.createBufferSource();
            click.buffer = clickBuffer;
            const clickGain = ctx.createGain();
            clickGain.gain.value = clickLevel * vel * 3;
            click.connect(clickGain);
            clickGain.connect(voiceGain);
            click.start(when);
        }
        
        const adsr = currentPreset.adsr || { a: 0.008, d: 0.05, s: 0.95, r: 0.15 };
        const voiceState = triggerAttack(ctx, voiceGain, when, adsr.a, adsr.d, adsr.s, vel);
        
        activeVoices.set(midi, { oscs, gains, voiceGain, voiceState, click });
    };
    
    const noteOff = (midi: number, when = ctx.currentTime) => {
        const voice = activeVoices.get(midi);
        if (!voice) return;
        
        const adsr = currentPreset.adsr || { a: 0.008, d: 0.05, s: 0.95, r: 0.15 };
        const stopTime = triggerRelease(ctx, voice.voiceState, when, adsr.a, adsr.r);
        
        voice.oscs.forEach(osc => osc.stop(stopTime + 0.1));
        
        setTimeout(() => {
            try { voice.voiceGain.disconnect(); } catch {}
        }, (stopTime - ctx.currentTime + 0.2) * 1000);
        
        activeVoices.delete(midi);
    };
    
    const allNotesOff = () => {
        activeVoices.forEach((_, midi) => noteOff(midi, ctx.currentTime));
    };
    
    const setLeslieMode = (mode: 'slow' | 'fast' | 'stop') => {
        const now = ctx.currentTime;
        const targetSpeed = mode === 'fast' ? 6.5 : mode === 'slow' ? 0.7 : 0;
        const accel = currentPreset.leslie?.accel ?? 0.5;
        
        leslieLfo.frequency.setTargetAtTime(targetSpeed, now, accel);
        tremoloLfo.frequency.setTargetAtTime(targetSpeed, now, accel);
    };
    
    const setPreset = (p: any) => {
        allNotesOff();
        currentPreset = { ...p };
        
        lpf.frequency.value = p.lpf ?? 3500;
        hpf.frequency.value = p.hpf ?? 60;
        vibratoLfo.frequency.value = p.vibratoRate ?? 6;
        vibratoGain.gain.value = (p.vibratoDepth ?? 0.003) * 100;
        organChorus.setMix(p.chorusMix ?? 0.2);
        revSend.gain.value = p.reverbMix ?? 0.2;
        
        if (p.leslie?.mode) setLeslieMode(p.leslie.mode);
        if (p.volume !== undefined) instrumentGain.gain.value = p.volume;
    };
    
    const setParam = (k: string, v: any) => {
        if (k === 'leslie') setLeslieMode(v);
        if (k === 'lpf') lpf.frequency.setTargetAtTime(v, ctx.currentTime, 0.05);
        if (k === 'reverbMix') revSend.gain.value = v;
    };
    
    return { noteOn, noteOff, allNotesOff, setPreset, setParam };
};

// ═══════════════════════════════════════════════════════════════════════════
// BASS ENGINE
// ═══════════════════════════════════════════════════════════════════════════

const buildBassEngine = (
    ctx: AudioContext,
    preset: any,
    master: GainNode,
    reverb: ConvolverNode,
    instrumentGain: GainNode,
    expressionGain: GainNode
): Partial<InstrumentAPI> => {
    
    let currentPreset = { ...preset };
    
    // ─── Static chain ───
    
    // Pre-amp compression
    const inputComp = ctx.createDynamicsCompressor();
    inputComp.threshold.value = -24;
    inputComp.ratio.value = 4;
    inputComp.attack.value = 0.005;
    inputComp.release.value = 0.1;
    
    // Drive
    const shaper = ctx.createWaveShaper();
    shaper.oversample = '2x';
    shaper.curve = makeTubeSaturation(currentPreset.drive?.amount ?? 0.2);
    
    const driveMix = ctx.createGain();
    driveMix.gain.value = currentPreset.drive?.on ? 0.5 : 0;
    const dryMix = ctx.createGain();
    dryMix.gain.value = 1;
    
    // Main filter
    const lpf = ctx.createBiquadFilter();
    lpf.type = 'lowpass';
    lpf.frequency.value = currentPreset.filter?.cutoff ?? 1200;
    lpf.Q.value = currentPreset.filter?.q ?? 1;
    
    // HPF — КРИТИЧЕСКИ ВАЖЕН для баса!
    const hpf = ctx.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = currentPreset.hpf ?? 35; // Срезаем гул ниже 35Hz
    hpf.Q.value = 0.7;
    
    // EQ
    const lowShelf = ctx.createBiquadFilter();
    lowShelf.type = 'lowshelf';
    lowShelf.frequency.value = currentPreset.eq?.low?.freq ?? 80;
    lowShelf.gain.value = currentPreset.eq?.low?.gain ?? 0;
    
    const midPeak = ctx.createBiquadFilter();
    midPeak.type = 'peaking';
    midPeak.frequency.value = currentPreset.eq?.mid?.freq ?? 800;
    midPeak.Q.value = currentPreset.eq?.mid?.q ?? 1;
    midPeak.gain.value = currentPreset.eq?.mid?.gain ?? 0;
    
    // Output compression
    const outputComp = ctx.createDynamicsCompressor();
    outputComp.threshold.value = currentPreset.comp?.threshold ?? -18;
    outputComp.ratio.value = currentPreset.comp?.ratio ?? 4;
    outputComp.attack.value = 0.005;
    outputComp.release.value = 0.15;
    
    const compMakeup = ctx.createGain();
    compMakeup.gain.value = dB(currentPreset.comp?.makeup ?? 4);
    
    // FX
    const chorus = makeChorus(ctx, 0.3, 0.003, currentPreset.chorus?.on ? 0.15 : 0);
    
    const revSend = ctx.createGain();
    revSend.gain.value = currentPreset.reverbMix ?? 0.05; // Бас — мало ревера!
    
    // Routing
    const bassSum = ctx.createGain();
    bassSum.connect(inputComp);
    
    inputComp.connect(shaper);
    shaper.connect(driveMix);
    inputComp.connect(dryMix);
    
    const driveOut = ctx.createGain();
    driveMix.connect(driveOut);
    dryMix.connect(driveOut);
    
    driveOut.connect(lpf);
    lpf.connect(hpf);
    hpf.connect(lowShelf);
    lowShelf.connect(midPeak);
    midPeak.connect(outputComp);
    outputComp.connect(compMakeup);
    compMakeup.connect(chorus.input);
    chorus.output.connect(expressionGain);
    expressionGain.connect(instrumentGain);
    instrumentGain.connect(master);
    
    chorus.output.connect(revSend);
    revSend.connect(reverb);
    
    // String noise
    const noiseBuffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.02), ctx.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i * 0.0003);
    }
    
    // Voice management
    interface BassVoice {
        oscs: OscillatorNode[];
        sub?: OscillatorNode;
        voiceGain: GainNode;
        voiceState: VoiceGain;
        noise?: AudioBufferSourceNode;
    }
    
    const activeVoices = new Map<number, BassVoice>();
    
    const noteOn = (midi: number, when = ctx.currentTime, velocity = 1.0) => {
        if (activeVoices.has(midi)) noteOff(midi, when);
        
        const f = midiToHz(midi);
        const vel = clamp(velocity, 0, 1);
        
        const voiceGain = ctx.createGain();
        voiceGain.gain.value = 0;
        voiceGain.connect(bassSum);
        
        const oscs: OscillatorNode[] = [];
        const oscConfigs = currentPreset.osc || [{ type: 'sawtooth', gain: 0.7, octave: 0 }];
        
        for (const o of oscConfigs) {
            const osc = ctx.createOscillator();
            osc.type = (o.type as OscillatorType) || 'sawtooth';
            osc.frequency.value = f * Math.pow(2, o.octave || 0);
            osc.detune.value = o.detune || 0;
            
            const g = ctx.createGain();
            g.gain.value = (o.gain ?? 0.7) * vel;
            
            osc.connect(g).connect(voiceGain);
            osc.start(when);
            oscs.push(osc);
        }
        
        // Sub oscillator
        let sub: OscillatorNode | undefined;
        if (currentPreset.sub?.on !== false) {
            sub = ctx.createOscillator();
            sub.type = (currentPreset.sub?.type as OscillatorType) || 'sine';
            sub.frequency.value = f * Math.pow(2, currentPreset.sub?.octave ?? -1);
            
            const subG = ctx.createGain();
            subG.gain.value = (currentPreset.sub?.gain ?? 0.5) * vel;
            
            sub.connect(subG).connect(voiceGain);
            sub.start(when);
        }
        
        // String noise
        let noise: AudioBufferSourceNode | undefined;
        if (currentPreset.stringNoise?.on !== false && vel > 0.3) {
            noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            const ng = ctx.createGain();
            ng.gain.value = (currentPreset.stringNoise?.amount ?? 0.1) * vel;
            
            const noiseHPF = ctx.createBiquadFilter();
            noiseHPF.type = 'highpass';
            noiseHPF.frequency.value = 1000;
            
            noise.connect(noiseHPF).connect(ng).connect(voiceGain);
            noise.start(when);
        }
        
        // Filter envelope
        if (currentPreset.filterEnv?.on) {
            const baseCutoff = currentPreset.filter?.cutoff ?? 1200;
            const depth = currentPreset.filterEnv?.depth ?? 500;
            const attack = currentPreset.filterEnv?.attack ?? 0.01;
            const decay = currentPreset.filterEnv?.decay ?? 0.2;
            
            lpf.frequency.cancelScheduledValues(when);
            lpf.frequency.setValueAtTime(baseCutoff, when);
            lpf.frequency.linearRampToValueAtTime(baseCutoff + depth * vel, when + attack);
            lpf.frequency.setTargetAtTime(baseCutoff, when + attack, decay / 3);
        }
        
        const adsr = currentPreset.adsr || { a: 0.01, d: 0.15, s: 0.7, r: 0.25 };
        const voiceState = triggerAttack(ctx, voiceGain, when, adsr.a, adsr.d, adsr.s, vel);
        
        activeVoices.set(midi, { oscs, sub, voiceGain, voiceState, noise });
    };
    
    const noteOff = (midi: number, when = ctx.currentTime) => {
        const voice = activeVoices.get(midi);
        if (!voice) return;
        
        const adsr = currentPreset.adsr || { a: 0.01, d: 0.15, s: 0.7, r: 0.25 };
        const stopTime = triggerRelease(ctx, voice.voiceState, when, adsr.a, adsr.r);
        
        voice.oscs.forEach(osc => osc.stop(stopTime + 0.1));
        if (voice.sub) voice.sub.stop(stopTime + 0.1);
        
        setTimeout(() => {
            try { voice.voiceGain.disconnect(); } catch {}
        }, (stopTime - ctx.currentTime + 0.2) * 1000);
        
        activeVoices.delete(midi);
    };
    
    const allNotesOff = () => {
        activeVoices.forEach((_, midi) => noteOff(midi, ctx.currentTime));
    };
    
    const setPreset = (p: any) => {
        allNotesOff();
        currentPreset = { ...p };
        
        lpf.frequency.value = p.filter?.cutoff ?? 1200;
        lpf.Q.value = p.filter?.q ?? 1;
        hpf.frequency.value = p.hpf ?? 35;
        
        shaper.curve = makeTubeSaturation(p.drive?.amount ?? 0.2);
        driveMix.gain.value = p.drive?.on ? 0.5 : 0;
        
        outputComp.threshold.value = p.comp?.threshold ?? -18;
        outputComp.ratio.value = p.comp?.ratio ?? 4;
        compMakeup.gain.value = dB(p.comp?.makeup ?? 4);
        
        chorus.setMix(p.chorus?.on ? 0.15 : 0);
        revSend.gain.value = p.reverbMix ?? 0.05;
        
        if (p.volume !== undefined) instrumentGain.gain.value = p.volume;
    };
    
    const setParam = (k: string, v: any) => {
        if (k === 'filterCutoff') lpf.frequency.setTargetAtTime(v, ctx.currentTime, 0.02);
        if (k === 'drive') {
            shaper.curve = makeTubeSaturation(v);
        }
    };
    
    return { noteOn, noteOff, allNotesOff, setPreset, setParam };
};

// ═══════════════════════════════════════════════════════════════════════════
// GUITAR ENGINE (Simplified)
// ═══════════════════════════════════════════════════════════════════════════

const buildGuitarEngine = (
    ctx: AudioContext,
    preset: any,
    master: GainNode,
    reverb: ConvolverNode,
    instrumentGain: GainNode,
    expressionGain: GainNode
): Partial<InstrumentAPI> => {
    
    let currentPreset = { ...preset };
    
    // ─── Static chain ───
    const guitarInput = ctx.createGain();
    
    // Pickup sim
    const pickupLPF = ctx.createBiquadFilter();
    pickupLPF.type = 'lowpass';
    pickupLPF.frequency.value = currentPreset.pickup?.cutoff ?? 4000;
    pickupLPF.Q.value = 1;
    
    const hpf = ctx.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = 80;
    
    // Drive
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = currentPreset.comp?.threshold ?? -18;
    comp.ratio.value = currentPreset.comp?.ratio ?? 3;
    
    const shaper = ctx.createWaveShaper();
    shaper.oversample = '4x';
    const driveType = currentPreset.drive?.type ?? 'soft';
    const driveAmt = currentPreset.drive?.amount ?? 0.3;
    shaper.curve = driveType === 'muff' ? makeMuff(driveAmt) : makeSoftClip(driveAmt);
    
    const compMakeup = ctx.createGain();
    compMakeup.gain.value = dB(currentPreset.comp?.makeup ?? 3);
    
    // EQ
    const mid1 = ctx.createBiquadFilter();
    mid1.type = 'peaking';
    mid1.frequency.value = 800;
    mid1.Q.value = 1;
    mid1.gain.value = 2;
    
    const mid2 = ctx.createBiquadFilter();
    mid2.type = 'peaking';
    mid2.frequency.value = 2500;
    mid2.Q.value = 1.5;
    mid2.gain.value = -1;
    
    const postLPF = ctx.createBiquadFilter();
    postLPF.type = 'lowpass';
    postLPF.frequency.value = currentPreset.post?.lpf ?? 5000;
    
    // FX
    const chorus = makeChorus(ctx, 0.15, 0.005, currentPreset.chorus?.on ? 0.3 : 0);
    const delay = makeDelay(ctx, 
        currentPreset.delay?.time ?? 0.35,
        currentPreset.delay?.fb ?? 0.3,
        3500,
        currentPreset.delay?.on ? (currentPreset.delay?.mix ?? 0.25) : 0
    );
    
    const revSend = ctx.createGain();
    revSend.gain.value = currentPreset.reverbMix ?? 0.2;
    
    // Routing
    guitarInput.connect(pickupLPF);
    pickupLPF.connect(hpf);
    hpf.connect(comp);
    comp.connect(shaper);
    shaper.connect(compMakeup);
    compMakeup.connect(mid1);
    mid1.connect(mid2);
    mid2.connect(postLPF);
    postLPF.connect(chorus.input);
    chorus.output.connect(delay.input);
    delay.output.connect(expressionGain);
    expressionGain.connect(instrumentGain);
    instrumentGain.connect(master);
    
    delay.output.connect(revSend);
    revSend.connect(reverb);
    
    // Pulse osc helper
    const createPulseOsc = (freq: number, width = 0.5) => {
        const w = clamp(width, 0.1, 0.9);
        const real = new Float32Array(32);
        const imag = new Float32Array(32);
        for (let n = 1; n < 32; n++) {
            real[n] = (2 / (n * Math.PI)) * Math.sin(n * Math.PI * w);
        }
        const wave = ctx.createPeriodicWave(real, imag, { disableNormalization: true });
        const osc = ctx.createOscillator();
        osc.setPeriodicWave(wave);
        osc.frequency.value = freq;
        return osc;
    };
    
    // Voice management
    interface GuitarVoice {
        oscMain: OscillatorNode;
        oscDet: OscillatorNode;
        oscSub: OscillatorNode;
        voiceGain: GainNode;
        voiceState: VoiceGain;
    }
    
    const activeVoices = new Map<number, GuitarVoice>();
    
    const noteOn = (midi: number, when = ctx.currentTime, velocity = 1.0) => {
        if (activeVoices.has(midi)) noteOff(midi, when);
        
        const f = midiToHz(midi);
        const vel = clamp(velocity, 0, 1);
        const oscP = currentPreset.osc || {};
        
        const voiceGain = ctx.createGain();
        voiceGain.gain.value = 0;
        voiceGain.connect(guitarInput);
        
        const sum = ctx.createGain();
        sum.gain.value = 0.7;
        sum.connect(voiceGain);
        
        const oscMain = createPulseOsc(f, oscP.width ?? 0.45);
        const oscDet = createPulseOsc(f, (oscP.width ?? 0.45) + 0.06);
        oscDet.detune.value = oscP.detune ?? 5;
        
        const oscSub = ctx.createOscillator();
        oscSub.type = 'sine';
        oscSub.frequency.value = f / 2;
        
        const gMain = ctx.createGain(); gMain.gain.value = (oscP.mainGain ?? 0.8) * vel;
        const gDet = ctx.createGain(); gDet.gain.value = (oscP.detGain ?? 0.2) * vel;
        const gSub = ctx.createGain(); gSub.gain.value = (oscP.subGain ?? 0.25) * vel;
        
        oscMain.connect(gMain).connect(sum);
        oscDet.connect(gDet).connect(sum);
        oscSub.connect(gSub).connect(sum);
        
        oscMain.start(when);
        oscDet.start(when);
        oscSub.start(when);
        
        const adsr = currentPreset.adsr || { a: 0.005, d: 0.3, s: 0.6, r: 1.5 };
        const voiceState = triggerAttack(ctx, voiceGain, when, adsr.a, adsr.d, adsr.s, vel);
        
        activeVoices.set(midi, { oscMain, oscDet, oscSub, voiceGain, voiceState });
    };
    
    const noteOff = (midi: number, when = ctx.currentTime) => {
        const voice = activeVoices.get(midi);
        if (!voice) return;
        
        const adsr = currentPreset.adsr || { a: 0.005, d: 0.3, s: 0.6, r: 1.5 };
        const stopTime = triggerRelease(ctx, voice.voiceState, when, adsr.a, adsr.r);
        
        voice.oscMain.stop(stopTime + 0.1);
        voice.oscDet.stop(stopTime + 0.1);
        voice.oscSub.stop(stopTime + 0.1);
        
        setTimeout(() => {
            try { voice.voiceGain.disconnect(); } catch {}
        }, (stopTime - ctx.currentTime + 0.2) * 1000);
        
        activeVoices.delete(midi);
    };
    
    const allNotesOff = () => {
        activeVoices.forEach((_, midi) => noteOff(midi, ctx.currentTime));
    };
    
    const setPreset = (p: any) => {
        allNotesOff();
        currentPreset = { ...p };
        
        pickupLPF.frequency.value = p.pickup?.cutoff ?? 4000;
        
        const driveType = p.drive?.type ?? 'soft';
        const driveAmt = p.drive?.amount ?? 0.3;
        shaper.curve = driveType === 'muff' ? makeMuff(driveAmt) : makeSoftClip(driveAmt);
        
        comp.threshold.value = p.comp?.threshold ?? -18;
        comp.ratio.value = p.comp?.ratio ?? 3;
        compMakeup.gain.value = dB(p.comp?.makeup ?? 3);
        
        postLPF.frequency.value = p.post?.lpf ?? 5000;
        
        chorus.setMix(p.chorus?.on ? 0.3 : 0);
        delay.setMix(p.delay?.on ? (p.delay?.mix ?? 0.25) : 0);
        revSend.gain.value = p.reverbMix ?? 0.2;
        
        if (p.volume !== undefined) instrumentGain.gain.value = p.volume;
    };
    
    const setParam = (k: string, v: any) => {
        if (k === 'drive') {
            shaper.curve = currentPreset.drive?.type === 'muff' ? makeMuff(v) : makeSoftClip(v);
        }
    };
    
    return { noteOn, noteOff, allNotesOff, setPreset, setParam };
};

// ═══════════════════════════════════════════════════════════════════════════
// MAIN FACTORY
// ═══════════════════════════════════════════════════════════════════════════

export async function buildMultiInstrument(ctx: AudioContext, {
    type = 'synth',
    preset = {} as any,
    cabinetIRUrl = null as string | null,
    plateIRUrl = null as string | null,
    output = ctx.destination
} = {}): Promise<InstrumentAPI> {
    
    console.log(`%c[Factory] Building: ${type}`, 'color: #FFA500; font-weight: bold;');
    
    // ─── Master Section ───
    const master = ctx.createGain();
    master.gain.value = 0.8;
    
    const instrumentGain = ctx.createGain();
    instrumentGain.gain.value = preset.volume ?? 0.7;
    
    const expressionGain = ctx.createGain();
    expressionGain.gain.value = 1;
    
    // Reverb
    const reverb = ctx.createConvolver();
    const reverbWet = ctx.createGain();
    reverbWet.gain.value = 0;
    
    if (plateIRUrl) {
        loadIR(ctx, plateIRUrl).then(buf => {
            if (buf) {
                reverb.buffer = buf;
                reverbWet.gain.value = 1;
            }
        });
    }
    
    reverb.connect(reverbWet);
    reverbWet.connect(master);
    
    // ─── Build Engine ───
    let engine: Partial<InstrumentAPI> = {};
    
    switch (type) {
        case 'synth':
            engine = buildSynthEngine(ctx, preset, master, reverb, instrumentGain, expressionGain);
            break;
        case 'organ':
            engine = buildOrganEngine(ctx, preset, master, reverb, instrumentGain, expressionGain);
            break;
        case 'bass':
            engine = buildBassEngine(ctx, preset, master, reverb, instrumentGain, expressionGain);
            break;
        case 'guitar':
            engine = buildGuitarEngine(ctx, preset, master, reverb, instrumentGain, expressionGain);
            break;
        default:
            console.warn(`[Factory] Unknown type: ${type}, using synth`);
            engine = buildSynthEngine(ctx, preset, master, reverb, instrumentGain, expressionGain);
    }
    
    // ─── Final Connection ───
    master.connect(output);
    
    // ─── API ───
    const api: InstrumentAPI = {
        connect: (dest?) => master.connect(dest || output),
        disconnect: () => { try { master.disconnect(); } catch {} },
        
        noteOn: engine.noteOn || (() => {}),
        noteOff: engine.noteOff || (() => {}),
        allNotesOff: engine.allNotesOff || (() => {}),
        setPreset: engine.setPreset || (() => {}),
        setParam: engine.setParam || (() => {}),
        
        setVolume: (v) => instrumentGain.gain.setTargetAtTime(clamp(v, 0, 1), ctx.currentTime, 0.02),
        getVolume: () => instrumentGain.gain.value,
        setExpression: (v) => expressionGain.gain.setTargetAtTime(clamp(v, 0, 1), ctx.currentTime, 0.01),
        
        preset,
        type
    };
    
    console.log(`%c[Factory] Ready: ${type}`, 'color: #32CD32; font-weight: bold;');
    return api;
}
