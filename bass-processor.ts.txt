// public/worklets/bass-processor.js
class BassProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [
      { name: 'cutoff', defaultValue: 400, minValue: 50, maxValue: 2000 },
      { name: 'resonance', defaultValue: 0.7, minValue: 0.1, maxValue: 5 },
      { name: 'distortion', defaultValue: 0.05, minValue: 0, maxValue: 1 },
      { name: 'portamento', defaultValue: 0.0, minValue: 0, maxValue: 0.5 }
    ];
  }

  constructor() {
    super();
    this.sampleRate = 44100;
    this.activeNotes = new Map();
    this.lastFreq = 0;
    this.portamentoTime = 0;
    this.portamentoTarget = 0;
    this.portamentoStartTime = 0;
    this.technique = 'pluck';
    this.dynamics = 0.7; // mf
    this.isLegato = false;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const cutoff = parameters.cutoff;
    const resonance = parameters.resonance;
    const distortion = parameters.distortion;
    const portamento = parameters.portamento;

    // Обновление состояния портаменто
    if (this.portamentoTime > 0) {
      const t = (currentFrame - this.portamentoStartTime) / this.sampleRate;
      if (t >= this.portamentoTime) {
        this.lastFreq = this.portamentoTarget;
        this.portamentoTime = 0;
      } else {
        const progress = t / this.portamentoTime;
        this.lastFreq = this.lastFreq * (1 - progress) + this.portamentoTarget * progress;
      }
    }

    // Генерация звука
    for (let channel = 0; channel < output.length; channel++) {
      const channelData = output[channel];
      for (let i = 0; i < channelData.length; i++) {
        let sample = 0;

        // Все активные ноты
        for (const [freq, note] of this.activeNotes) {
          const phase = note.phase;
          const wave1 = this.pulseWave(phase, 0.5); // pulse для атаки
          const wave2 = Math.sin(phase * 0.5);      // sine для суб-баса

          // Фильтр (упрощённый state-variable)
          const filtered = this.lowpassFilter(wave1 + wave2 * 0.7, cutoff[0], resonance[0]);

          // Дисторшн
          const distorted = this.softClip(filtered, distortion[0]);

          sample += distorted * note.gain;
          note.phase += (freq * 2 * Math.PI) / this.sampleRate;
        }

        channelData[i] = sample * 0.3; // общий уровень
      }
    }

    // Управление затуханием нот
    for (const [freq, note] of this.activeNotes) {
      if (note.state === 'decay') {
        note.gain *= 0.995;
        if (note.gain < 0.001) {
          this.activeNotes.delete(freq);
        }
      }
    }

    return true;
  }

  // Волновые формы
  pulseWave(phase, width) {
    return (phase % (2 * Math.PI)) < width * 2 * Math.PI ? 1 : -1;
  }

  // Фильтр (упрощённый)
  lowpassFilter(input, cutoff, q) {
    // Реализация state-variable filter — можно расширить
    return input * Math.exp(-cutoff / 2000);
  }

  // Дисторшн
  softClip(input, drive) {
    const k = 2 * drive;
    return (input * (1 + k)) / (1 + k * Math.abs(input));
  }

  // Обработка сообщений
  onmessage(event) {
    const { type, ...data } = event.data;
    if (type === 'noteOn') {
      const { frequency, velocity } = data;
      const isLegato = this.activeNotes.size > 0;
      this.portamentoTarget = frequency;
      if (isLegato && this.parameters.portamento.value > 0) {
        this.portamentoTime = this.parameters.portamento.value;
        this.portamentoStartTime = currentFrame;
      } else {
        this.lastFreq = frequency;
        this.portamentoTime = 0;
      }
      this.activeNotes.set(frequency, {
        phase: 0,
        gain: velocity,
        state: 'attack'
      });
    } else if (type === 'noteOff') {
      for (const note of this.activeNotes.values()) {
        note.state = 'decay';
      }
    } else if (type === 'setTechnique') {
      this.technique = data.technique;
      // Техника влияет на параметры через параметры узла
    }
  }
}

registerProcessor('bass-processor', BassProcessor);
