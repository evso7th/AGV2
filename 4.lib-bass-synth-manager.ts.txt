Суть проблемы
BassSynthManager не должен знать о mood, getScaleForMood или музыкальной теории.
Его единственная задача — воспроизвести то, что ему дал композитор, точно по времени, с правильными параметрами синтеза. 

Когда менеджер начинает принимать музыкальные решения — он дублирует логику композитора, создаёт два источника истины и ломает разделение слоёв.

✅ Правильная архитектура
FractalMusicEngine
Композитор
Генерирует
FractalEvent[]
с
полными параметрами
:
technique
,
cutoff
,
resonance
,
distortion
,
portamento
BassSynthManager
Исполнитель
Получает
FractalEvent[]
→
без вопросов
применяет параметры → воспроизводит звук

→ Нет импорта music-theory в менеджер.
→ Нет поля mood в менеджере.
→ Нет вызова getParamsForTechnique() в менеджере.




Цель
Превратить бас-синтезатор в динамическую машину, которая:

Принимает событие с technique: 'pluck' | 'ghost' | 'slap',
Преобразует технику в полный набор параметров,
Передаёт параметры в ворклет sample-accurate,
Поддерживает полифонию и портаменто.

// src/lib/bass-synth-manager.ts
// src/lib/bass-synth-manager.ts
import type { FractalEvent } from '@/types/fractal';

/**
 * BassSynthManager — "Исполнитель"
 * Его единственная задача: получить событие FractalEvent и точно воспроизвести его
 * в заданное время с заданными параметрами синтеза.
 */
export class BassSynthManager {
  private ctx: AudioContext;
  private worklet: AudioWorkletNode | null = null;
  private destination: AudioNode;
  private isInitialized = false;

  constructor(ctx: AudioContext, destination: AudioNode) {
    this.ctx = ctx;
    this.destination = destination;
  }

  async init() {
    if (this.isInitialized) return;
    try {
      await this.ctx.audioWorklet.addModule('/worklets/bass-processor.js');
      this.worklet = new AudioWorkletNode(this.ctx, 'bass-processor');
      this.worklet.connect(this.destination);
      this.isInitialized = true;
      console.log('[BassSynthManager] Initialized');
    } catch (e) {
      console.error('[BassSynthManager] Failed to init:', e);
    }
  }

  /**
   * Воспроизводит одно событие баса.
   * Все параметры синтеза уже содержатся в событии.
   */
  public play(event: FractalEvent) {
    if (!this.isInitialized || !this.worklet) {
      console.warn('[BassSynthManager] Not ready, skipping event');
      return;
    }

    // Защита от некорректного времени
    if (!isFinite(event.time)) {
      console.warn('[BassSynthManager] Non-finite time in event:', event);
      return;
    }

    const noteOnTime = this.ctx.currentTime + event.time;
    if (!isFinite(noteOnTime)) return;

    // Извлечение параметров ИЗ СОБЫТИЯ (не генерация!)
    const { cutoff, resonance, distortion, portamento } = event.params;

    // Установка параметров через AudioParam (sample-accurate)
    this.setParam('cutoff', cutoff, noteOnTime);
    this.setParam('resonance', resonance, noteOnTime);
    this.setParam('distortion', distortion, noteOnTime);
    this.setParam('portamento', portamento, noteOnTime);

    // Расчёт частоты
    const freq = 440 * Math.pow(2, (event.note - 69) / 12);
    if (!isFinite(freq)) return;

    // Отправка ноты в ворклет
    this.worklet.port.postMessage({
      type: 'noteOn',
      frequency: freq,
      velocity: this.getVelocity(event.dynamics),
      time: noteOnTime
    });
  }

  // Вспомогательные методы

  private setParam(name: string, value: number, time: number) {
    const param = this.worklet?.parameters.get(name);
    if (param && isFinite(value)) {
      param.setValueAtTime(value, time);
    }
  }

  private getVelocity(dynamics: string): number {
    switch (dynamics) {
      case 'p': return 0.3;
      case 'mf': return 0.6;
      default: return 0.9; // 'f'
    }
  }
}

 Замечание: beatDuration должен браться из tempo, но tempo не в AudioContext.
Решение: передавать tempo в конструктор BassSynthManager. 
→ Вся музыкальная логика — в композиторе.
→ Менеджер — глупый, но точный исполнитель.
