# Hammond-Style Organ Engine

ĞŸĞ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ°Ñ ÑĞ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ° Ñ drawbars, Leslie speaker, percussion Ğ¸ key click!

```typescript
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ORGAN ENGINE â€” Hammond B3 Style
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LESLIE SPEAKER EMULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface LeslieConfig {
    mode: 'stop' | 'slow' | 'fast';
    slow: number;      // Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ slow (Hz)
    fast: number;      // Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ fast (Hz)
    accel: number;     // Ğ’Ñ€ĞµĞ¼Ñ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ½Ğ°/Ñ‚Ğ¾Ñ€Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ (ÑĞµĞº)
    hornDepth: number; // Ğ“Ğ»ÑƒĞ±Ğ¸Ğ½Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»ÑÑ†Ğ¸Ğ¸ Ñ€ÑƒĞ¿Ğ¾Ñ€Ğ° (Ğ²Ñ‹ÑĞ¾ĞºĞ¸Ğµ)
    drumDepth: number; // Ğ“Ğ»ÑƒĞ±Ğ¸Ğ½Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»ÑÑ†Ğ¸Ğ¸ Ğ±Ğ°Ñ€Ğ°Ğ±Ğ°Ğ½Ğ° (Ğ½Ğ¸Ğ·ĞºĞ¸Ğµ)
    mix: number;       // Wet/dry
}

const createLeslie = (ctx: AudioContext, config: LeslieConfig) => {
    // Leslie Ğ¸Ğ¼ĞµĞµÑ‚ Ğ´Ğ²Ğ° Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑ‰Ğ¸Ñ…ÑÑ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°:
    // 1. Horn (Ñ€ÑƒĞ¿Ğ¾Ñ€) â€” Ğ´Ğ»Ñ Ğ²Ñ‹ÑĞ¾ĞºĞ¸Ñ… Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚, Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ
    // 2. Drum (Ğ±Ğ°Ñ€Ğ°Ğ±Ğ°Ğ½) â€” Ğ´Ğ»Ñ Ğ½Ğ¸Ğ·ĞºĞ¸Ñ…, Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½ĞµĞµ
    
    const input = ctx.createGain();
    const output = ctx.createGain();
    const dry = ctx.createGain();
    const wet = ctx.createGain();
    
    dry.gain.value = 1 - config.mix;
    wet.gain.value = config.mix;
    
    // â”€â”€â”€ Crossover (Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚) â”€â”€â”€
    const lowpass = ctx.createBiquadFilter();
    lowpass.type = 'lowpass';
    lowpass.frequency.value = 800;
    lowpass.Q.value = 0.5;
    
    const highpass = ctx.createBiquadFilter();
    highpass.type = 'highpass';
    highpass.frequency.value = 800;
    highpass.Q.value = 0.5;
    
    // â”€â”€â”€ Horn (Ğ²Ñ‹ÑĞ¾ĞºĞ¸Ğµ) â”€â”€â”€
    const hornDelay = ctx.createDelay(0.01);
    hornDelay.delayTime.value = 0.002;
    
    const hornLfo = ctx.createOscillator();
    hornLfo.type = 'sine';
    hornLfo.frequency.value = config.mode === 'fast' ? config.fast : config.slow;
    
    const hornLfoGain = ctx.createGain();
    hornLfoGain.gain.value = config.hornDepth * 0.001; // ĞœĞ¾Ğ´ÑƒĞ»ÑÑ†Ğ¸Ñ delay time
    
    const hornAmpLfo = ctx.createGain();
    hornAmpLfo.gain.value = 1;
    
    const hornAmpMod = ctx.createGain();
    hornAmpMod.gain.value = config.hornDepth * 0.15; // ĞœĞ¾Ğ´ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ³Ñ€Ğ¾Ğ¼ĞºĞ¾ÑÑ‚Ğ¸
    
    // â”€â”€â”€ Drum (Ğ½Ğ¸Ğ·ĞºĞ¸Ğµ) â€” Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ÑÑ Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½ĞµĞµ â”€â”€â”€
    const drumDelay = ctx.createDelay(0.01);
    drumDelay.delayTime.value = 0.003;
    
    const drumLfo = ctx.createOscillator();
    drumLfo.type = 'sine';
    drumLfo.frequency.value = (config.mode === 'fast' ? config.fast : config.slow) * 0.85;
    
    const drumLfoGain = ctx.createGain();
    drumLfoGain.gain.value = config.drumDepth * 0.0015;
    
    const drumAmpLfo = ctx.createGain();
    drumAmpLfo.gain.value = 1;
    
    const drumAmpMod = ctx.createGain();
    drumAmpMod.gain.value = config.drumDepth * 0.1;
    
    // â”€â”€â”€ Stereo spread â”€â”€â”€
    const pannerL = ctx.createStereoPanner();
    const pannerR = ctx.createStereoPanner();
    
    const panLfoL = ctx.createGain();
    const panLfoR = ctx.createGain();
    panLfoL.gain.value = 0.7;
    panLfoR.gain.value = -0.7;
    
    // â”€â”€â”€ Routing â”€â”€â”€
    // Dry path
    input.connect(dry);
    dry.connect(output);
    
    // Wet path â€” crossover
    input.connect(lowpass);
    input.connect(highpass);
    
    // Horn chain
    highpass.connect(hornDelay);
    hornDelay.connect(hornAmpLfo);
    hornAmpLfo.connect(pannerL);
    hornAmpLfo.connect(pannerR);
    
    hornLfo.connect(hornLfoGain);
    hornLfoGain.connect(hornDelay.delayTime);
    hornLfo.connect(hornAmpMod);
    hornAmpMod.connect(hornAmpLfo.gain);
    hornLfo.connect(panLfoL);
    panLfoL.connect(pannerL.pan);
    hornLfo.connect(panLfoR);
    panLfoR.connect(pannerR.pan);
    
    // Drum chain
    lowpass.connect(drumDelay);
    drumDelay.connect(drumAmpLfo);
    drumAmpLfo.connect(pannerL);
    drumAmpLfo.connect(pannerR);
    
    drumLfo.connect(drumLfoGain);
    drumLfoGain.connect(drumDelay.delayTime);
    drumLfo.connect(drumAmpMod);
    drumAmpMod.connect(drumAmpLfo.gain);
    
    // Mix
    pannerL.connect(wet);
    pannerR.connect(wet);
    wet.connect(output);
    
    // Start LFOs
    hornLfo.start();
    drumLfo.start();
    
    // â”€â”€â”€ Control â”€â”€â”€
    let currentMode = config.mode;
    let targetSpeed = config.mode === 'fast' ? config.fast : config.slow;
    
    const setMode = (mode: 'stop' | 'slow' | 'fast') => {
        currentMode = mode;
        const now = ctx.currentTime;
        
        let speed: number;
        switch (mode) {
            case 'stop': speed = 0.01; break;
            case 'slow': speed = config.slow; break;
            case 'fast': speed = config.fast; break;
        }
        
        // ĞŸĞ»Ğ°Ğ²Ğ½Ğ¾Ğµ ÑƒÑĞºĞ¾Ñ€ĞµĞ½Ğ¸Ğµ/Ñ‚Ğ¾Ñ€Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ (ĞºĞ°Ğº Ñƒ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Leslie)
        hornLfo.frequency.cancelScheduledValues(now);
        hornLfo.frequency.setTargetAtTime(speed, now, config.accel);
        
        drumLfo.frequency.cancelScheduledValues(now);
        drumLfo.frequency.setTargetAtTime(speed * 0.85, now, config.accel * 1.2);
    };
    
    const setMix = (mix: number) => {
        dry.gain.value = 1 - mix;
        wet.gain.value = mix;
    };
    
    return {
        input,
        output,
        setMode,
        setMix,
        getMode: () => currentMode
    };
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TONEWHEEL GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface TonewheelConfig {
    crosstalk: number;     // ĞœĞµĞ¶ĞºĞ¾Ğ»Ñ‘ÑĞ½Ğ¾Ğµ "Ğ¿Ñ€Ğ¾Ñ‚ĞµĞºĞ°Ğ½Ğ¸Ğµ" (0-1)
    leakage: number;       // Ğ£Ñ‚ĞµÑ‡ĞºĞ° (Ğ»Ñ‘Ğ³ĞºĞ¸Ğ¹ ÑˆÑƒĞ¼)
    complexity: number;    // Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ñ„Ğ¾Ñ€Ğ¼Ñ‹ Ğ²Ğ¾Ğ»Ğ½Ñ‹ (0=sine, 1=full harmonic)
}

const createTonewheelWave = (ctx: AudioContext, config: TonewheelConfig): PeriodicWave => {
    // Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ğ¾Ğ½ĞºĞ¾Ğ»Ñ‘ÑĞ° Ğ´Ğ°ÑÑ‚ Ğ½Ğµ Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¸Ğ½ÑƒÑ
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ»Ñ‘Ğ³ĞºĞ¸Ğµ Ğ³Ğ°Ñ€Ğ¼Ğ¾Ğ½Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ "Ñ‚Ñ‘Ğ¿Ğ»Ğ¾Ğ³Ğ¾" Ğ·Ğ²ÑƒÑ‡Ğ°Ğ½Ğ¸Ñ
    
    const real = new Float32Array(16);
    const imag = new Float32Array(16);
    
    real[0] = 0;
    real[1] = 1;                                    // ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ‚Ğ¾Ğ½
    real[2] = config.complexity * 0.02;             // 2-Ñ Ğ³Ğ°Ñ€Ğ¼Ğ¾Ğ½Ğ¸ĞºĞ°
    real[3] = config.complexity * 0.015;            // 3-Ñ
    real[4] = config.complexity * 0.008;            // 4-Ñ
    real[5] = config.complexity * 0.004;            // 5-Ñ
    
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ°ÑĞ¸Ğ¼Ğ¼ĞµÑ‚Ñ€Ğ¸Ñ (Ñ‡Ñ‘Ñ‚Ğ½Ñ‹Ğµ/Ğ½ĞµÑ‡Ñ‘Ñ‚Ğ½Ñ‹Ğµ)
    real[6] = config.complexity * 0.003;
    real[7] = config.complexity * 0.002;
    
    return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAWBAR RATIOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Hammond drawbar footage -> frequency ratio
const DRAWBAR_RATIOS = [
    0.5,      // 16'   â€” sub-octave
    1.498,    // 5â…“'   â€” 5th above (quint)
    1,        // 8'    â€” fundamental
    2,        // 4'    â€” octave
    2.997,    // 2â…”'   â€” octave + 5th
    4,        // 2'    â€” 2 octaves
    5.04,     // 1â…—'   â€” 2 octaves + major 3rd
    5.994,    // 1â…“'   â€” 2 octaves + 5th
    8         // 1'    â€” 3 octaves
];

const DRAWBAR_NAMES = ["16'", "5â…“'", "8'", "4'", "2â…”'", "2'", "1â…—'", "1â…“'", "1'"];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY CLICK GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const createKeyClick = (ctx: AudioContext, duration: number, intensity: number): AudioBuffer => {
    const length = Math.floor(ctx.sampleRate * duration);
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < length; i++) {
        const t = i / length;
        // ĞšĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğ¹ Ğ¸Ğ¼Ğ¿ÑƒĞ»ÑŒÑ Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¼ Ğ·Ğ°Ñ‚ÑƒÑ…Ğ°Ğ½Ğ¸ĞµĞ¼
        const envelope = Math.exp(-t * 30) * (1 - t);
        // Ğ¨ÑƒĞ¼Ğ¾Ğ²Ğ°Ñ ÑĞ¾ÑÑ‚Ğ°Ğ²Ğ»ÑÑÑ‰Ğ°Ñ + Ñ‚Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ
        const noise = (Math.random() * 2 - 1) * 0.6;
        const tone = Math.sin(i * 0.15) * 0.4; // ~1kHz "Ñ‚Ğ¸Ğº"
        data[i] = (noise + tone) * envelope * intensity;
    }
    
    return buffer;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VIBRATO/CHORUS SCANNER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface VibratoConfig {
    type: 'V1' | 'V2' | 'V3' | 'C1' | 'C2' | 'C3'; // Hammond vibrato types
    rate: number;
}

const VIBRATO_SETTINGS: Record<string, { depth: number; mix: number }> = {
    'V1': { depth: 0.0015, mix: 1.0 },
    'V2': { depth: 0.0025, mix: 1.0 },
    'V3': { depth: 0.0040, mix: 1.0 },
    'C1': { depth: 0.0015, mix: 0.5 },  // Chorus = vibrato + dry
    'C2': { depth: 0.0025, mix: 0.5 },
    'C3': { depth: 0.0040, mix: 0.5 },
};

const createVibratoScanner = (ctx: AudioContext, config: VibratoConfig) => {
    const settings = VIBRATO_SETTINGS[config.type] || VIBRATO_SETTINGS['C2'];
    
    const input = ctx.createGain();
    const output = ctx.createGain();
    const dry = ctx.createGain();
    const wet = ctx.createGain();
    
    dry.gain.value = 1 - settings.mix;
    wet.gain.value = settings.mix;
    
    // Ğ›Ğ¸Ğ½Ğ¸Ñ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ¸ Ğ´Ğ»Ñ pitch modulation
    const delay = ctx.createDelay(0.02);
    delay.delayTime.value = 0.005;
    
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = config.rate;
    
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = settings.depth;
    
    // Routing
    input.connect(dry);
    input.connect(delay);
    delay.connect(wet);
    dry.connect(output);
    wet.connect(output);
    
    lfo.connect(lfoGain);
    lfoGain.connect(delay.delayTime);
    lfo.start();
    
    return {
        input,
        output,
        setType: (type: VibratoConfig['type']) => {
            const s = VIBRATO_SETTINGS[type] || VIBRATO_SETTINGS['C2'];
            lfoGain.gain.setTargetAtTime(s.depth, ctx.currentTime, 0.1);
            dry.gain.setTargetAtTime(1 - s.mix, ctx.currentTime, 0.1);
            wet.gain.setTargetAtTime(s.mix, ctx.currentTime, 0.1);
        },
        setRate: (rate: number) => {
            lfo.frequency.setTargetAtTime(rate, ctx.currentTime, 0.1);
        }
    };
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERCUSSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface PercussionConfig {
    on: boolean;
    harmonic: '2nd' | '3rd';  // ĞšĞ°ĞºĞ°Ñ Ğ³Ğ°Ñ€Ğ¼Ğ¾Ğ½Ğ¸ĞºĞ°
    decay: 'fast' | 'slow';   // Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ Ğ·Ğ°Ñ‚ÑƒÑ…Ğ°Ğ½Ğ¸Ñ
    volume: 'soft' | 'normal';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN ORGAN ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface OrganPreset {
    type: 'organ';
    volume?: number;
    
    // Drawbars (0-8 Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ¸Ğ· 9 Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¾Ğ²)
    drawbars: number[];
    
    // Vibrato
    vibrato?: {
        type: 'V1' | 'V2' | 'V3' | 'C1' | 'C2' | 'C3' | 'off';
        rate?: number;
    };
    
    // Leslie
    leslie?: {
        on?: boolean;
        mode?: 'stop' | 'slow' | 'fast';
        slow?: number;
        fast?: number;
        accel?: number;
        mix?: number;
    };
    
    // Percussion
    percussion?: PercussionConfig;
    
    // Key click
    keyClick?: number;  // 0-1 intensity
    
    // Tonewheel character
    tonewheel?: TonewheelConfig;
    
    // Filters
    lpf?: number;
    hpf?: number;
    
    // FX
    reverbMix?: number;
    
    // ADSR
    adsr?: { a: number; d: number; s: number; r: number };
}

interface OrganVoice {
    oscillators: OscillatorNode[];
    gains: GainNode[];
    voiceGain: GainNode;
    percGain?: GainNode;
    percOsc?: OscillatorNode;
    clickSource?: AudioBufferSourceNode;
    startTime: number;
    midi: number;
}

export const buildOrganEngine = async (
    ctx: AudioContext,
    preset: OrganPreset,
    options: {
        output?: AudioNode;
        plateIRUrl?: string | null;
    } = {}
) => {
    console.log('%c[OrganEngine] Building Hammond-style organ...', 'color: #8B4513; font-weight: bold;');
    
    const output = options.output || ctx.destination;
    let currentPreset = { ...preset };
    
    // â•â•â• Audio Graph â•â•â•
    
    // Tonewheel wave
    const tonewheelConfig: TonewheelConfig = currentPreset.tonewheel || {
        crosstalk: 0.02,
        leakage: 0.01,
        complexity: 0.3
    };
    let tonewheelWave = createTonewheelWave(ctx, tonewheelConfig);
    
    // Key click buffer
    const clickIntensity = currentPreset.keyClick ?? 0.004;
    let clickBuffer = createKeyClick(ctx, 0.008, clickIntensity);
    
    // â”€â”€â”€ Signal Chain â”€â”€â”€
    const organSum = ctx.createGain();
    organSum.gain.value = 0.7;
    
    // HPF (remove rumble)
    const hpf = ctx.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = currentPreset.hpf ?? 60;
    hpf.Q.value = 0.5;
    
    // LPF (warmth)
    const lpf = ctx.createBiquadFilter();
    lpf.type = 'lowpass';
    lpf.frequency.value = currentPreset.lpf ?? 5000;
    lpf.Q.value = 0.5;
    
    // Vibrato Scanner
    const vibrato = createVibratoScanner(ctx, {
        type: currentPreset.vibrato?.type !== 'off' ? (currentPreset.vibrato?.type || 'C2') : 'C2',
        rate: currentPreset.vibrato?.rate ?? 6.5
    });
    const vibratoBypass = ctx.createGain();
    vibratoBypass.gain.value = currentPreset.vibrato?.type === 'off' ? 1 : 0;
    const vibratoWet = ctx.createGain();
    vibratoWet.gain.value = currentPreset.vibrato?.type === 'off' ? 0 : 1;
    
    // Leslie
    const leslieConfig: LeslieConfig = {
        mode: currentPreset.leslie?.mode ?? 'slow',
        slow: currentPreset.leslie?.slow ?? 0.8,
        fast: currentPreset.leslie?.fast ?? 6.5,
        accel: currentPreset.leslie?.accel ?? 0.8,
        hornDepth: 0.8,
        drumDepth: 0.5,
        mix: currentPreset.leslie?.mix ?? 0.7
    };
    const leslie = createLeslie(ctx, leslieConfig);
    const leslieBypass = ctx.createGain();
    leslieBypass.gain.value = currentPreset.leslie?.on === false ? 1 : 0;
    const leslieWet = ctx.createGain();
    leslieWet.gain.value = currentPreset.leslie?.on === false ? 0 : 1;
    
    // Volume control
    const instrumentGain = ctx.createGain();
    instrumentGain.gain.value = currentPreset.volume ?? 0.7;
    
    const expressionGain = ctx.createGain();
    expressionGain.gain.value = 1;
    
    // Master
    const master = ctx.createGain();
    master.gain.value = 0.8;
    
    // Reverb
    const reverb = ctx.createConvolver();
    const reverbWet = ctx.createGain();
    reverbWet.gain.value = currentPreset.reverbMix ?? 0.15;
    
    if (options.plateIRUrl) {
        try {
            const res = await fetch(options.plateIRUrl);
            const buf = await res.arrayBuffer();
            reverb.buffer = await ctx.decodeAudioData(buf);
        } catch (e) {
            console.warn('[OrganEngine] Could not load reverb IR');
        }
    }
    
    // â”€â”€â”€ Routing â”€â”€â”€
    organSum.connect(hpf);
    hpf.connect(lpf);
    
    // Vibrato (parallel wet/dry)
    lpf.connect(vibrato.input);
    lpf.connect(vibratoBypass);
    vibrato.output.connect(vibratoWet);
    
    const vibratoMerge = ctx.createGain();
    vibratoBypass.connect(vibratoMerge);
    vibratoWet.connect(vibratoMerge);
    
    // Leslie (parallel wet/dry)
    vibratoMerge.connect(leslie.input);
    vibratoMerge.connect(leslieBypass);
    leslie.output.connect(leslieWet);
    
    const leslieMerge = ctx.createGain();
    leslieBypass.connect(leslieMerge);
    leslieWet.connect(leslieMerge);
    
    // Final chain
    leslieMerge.connect(expressionGain);
    expressionGain.connect(instrumentGain);
    instrumentGain.connect(master);
    
    // Reverb send
    leslieMerge.connect(reverbWet);
    reverbWet.connect(reverb);
    reverb.connect(master);
    
    master.connect(output);
    
    // â•â•â• Voice Management â•â•â•
    const activeVoices = new Map<number, OrganVoice>();
    const midiToHz = (m: number) => 440 * Math.pow(2, (m - 69) / 12);
    const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));
    
    // â”€â”€â”€ Note On â”€â”€â”€
    const noteOn = (midi: number, when = ctx.currentTime, velocity = 1.0) => {
        // Ğ•ÑĞ»Ğ¸ Ğ½Ğ¾Ñ‚Ğ° ÑƒĞ¶Ğµ Ğ¸Ğ³Ñ€Ğ°ĞµÑ‚, ÑĞ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ²Ñ‹ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼
        if (activeVoices.has(midi)) {
            noteOff(midi, when);
        }
        
        const f0 = midiToHz(midi);
        const vel = clamp(velocity, 0, 1);
        const drawbars = currentPreset.drawbars || [8, 8, 8, 0, 0, 0, 0, 0, 0];
        const adsr = currentPreset.adsr || { a: 0.005, d: 0.1, s: 0.9, r: 0.1 };
        
        // Voice gain
        const voiceGain = ctx.createGain();
        voiceGain.gain.value = 0;
        voiceGain.connect(organSum);
        
        const oscillators: OscillatorNode[] = [];
        const gains: GainNode[] = [];
        
        // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¾ÑÑ†Ğ¸Ğ»Ğ»ÑÑ‚Ğ¾Ñ€ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ drawbar
        for (let i = 0; i < 9; i++) {
            const dbValue = drawbars[i] ?? 0;
            if (dbValue === 0) continue;
            
            const osc = ctx.createOscillator();
            osc.setPeriodicWave(tonewheelWave);
            osc.frequency.value = f0 * DRAWBAR_RATIOS[i];
            
            const gain = ctx.createGain();
            // Ğ“Ñ€Ğ¾Ğ¼ĞºĞ¾ÑÑ‚ÑŒ drawbar: 0-8 -> 0-1, Ñ ĞºĞ¾Ğ¼Ğ¿Ñ€ĞµÑÑĞ¸ĞµĞ¹
            gain.gain.value = (dbValue / 8) * 0.35 * vel;
            
            osc.connect(gain);
            gain.connect(voiceGain);
            osc.start(when);
            
            oscillators.push(osc);
            gains.push(gain);
        }
        
        // â”€â”€â”€ Percussion â”€â”€â”€
        let percGain: GainNode | undefined;
        let percOsc: OscillatorNode | undefined;
        
        if (currentPreset.percussion?.on && activeVoices.size === 0) {
            // Percussion Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½Ğ° Ğ¿ĞµÑ€Ğ²ÑƒÑ Ğ½Ğ¾Ñ‚Ñƒ (ĞºĞ°Ğº Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Hammond)
            const percHarmonic = currentPreset.percussion.harmonic === '3rd' ? 2.997 : 2;
            const percDecay = currentPreset.percussion.decay === 'slow' ? 0.5 : 0.2;
            const percVol = currentPreset.percussion.volume === 'soft' ? 0.15 : 0.25;
            
            percOsc = ctx.createOscillator();
            percOsc.setPeriodicWave(tonewheelWave);
            percOsc.frequency.value = f0 * percHarmonic;
            
            percGain = ctx.createGain();
            percGain.gain.value = percVol * vel;
            percGain.gain.setTargetAtTime(0, when, percDecay / 3);
            
            percOsc.connect(percGain);
            percGain.connect(voiceGain);
            percOsc.start(when);
            percOsc.stop(when + percDecay + 0.1);
        }
        
        // â”€â”€â”€ Key Click â”€â”€â”€
        let clickSource: AudioBufferSourceNode | undefined;
        
        if (clickIntensity > 0 && clickBuffer) {
            clickSource = ctx.createBufferSource();
            clickSource.buffer = clickBuffer;
            
            const clickGain = ctx.createGain();
            clickGain.gain.value = vel * 0.8;
            
            clickSource.connect(clickGain);
            clickGain.connect(voiceGain);
            clickSource.start(when);
        }
        
        // â”€â”€â”€ Envelope â”€â”€â”€
        voiceGain.gain.cancelScheduledValues(when);
        voiceGain.gain.setValueAtTime(0.0001, when);
        voiceGain.gain.linearRampToValueAtTime(1, when + adsr.a);
        voiceGain.gain.setTargetAtTime(adsr.s, when + adsr.a, Math.max(adsr.d / 3, 0.001));
        
        activeVoices.set(midi, {
            oscillators,
            gains,
            voiceGain,
            percGain,
            percOsc,
            clickSource,
            startTime: when,
            midi
        });
    };
    
    // â”€â”€â”€ Note Off â”€â”€â”€
    const noteOff = (midi: number, when = ctx.currentTime) => {
        const voice = activeVoices.get(midi);
        if (!voice) return;
        
        const adsr = currentPreset.adsr || { a: 0.005, d: 0.1, s: 0.9, r: 0.1 };
        const releaseTime = Math.max(adsr.r, 0.02);
        
        // Ğ£Ğ¼Ğ½Ñ‹Ğ¹ release (Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹)
        const elapsed = when - voice.startTime;
        const currentGain = voice.voiceGain.gain.value;
        
        voice.voiceGain.gain.cancelScheduledValues(when);
        
        if (elapsed < adsr.a) {
            // Ğ•Ñ‰Ñ‘ Ğ² Ğ°Ñ‚Ğ°ĞºĞµ â€” Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ¼Ğ¸ĞºÑ€Ğ¾-release
            voice.voiceGain.gain.setValueAtTime(currentGain, when);
            voice.voiceGain.gain.setTargetAtTime(0.0001, when, 0.02);
        } else {
            // ĞĞ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ release
            voice.voiceGain.gain.setValueAtTime(currentGain, when);
            voice.voiceGain.gain.setTargetAtTime(0.0001, when, releaseTime / 3);
        }
        
        // Key click Ğ½Ğ° release (Ñ‚Ğ¸ÑˆĞµ)
        if (clickIntensity > 0 && clickBuffer) {
            const releaseClick = ctx.createBufferSource();
            releaseClick.buffer = clickBuffer;
            const clickGain = ctx.createGain();
            clickGain.gain.value = 0.3;
            releaseClick.connect(clickGain);
            clickGain.connect(voice.voiceGain);
            releaseClick.start(when);
        }
        
        const stopTime = when + releaseTime + 0.1;
        voice.oscillators.forEach(osc => osc.stop(stopTime));
        if (voice.percOsc) {
            try { voice.percOsc.stop(stopTime); } catch {}
        }
        
        activeVoices.delete(midi);
    };
    
    // â”€â”€â”€ All Notes Off â”€â”€â”€
    const allNotesOff = () => {
        const now = ctx.currentTime;
        activeVoices.forEach((voice, midi) => {
            voice.voiceGain.gain.cancelScheduledValues(now);
            voice.voiceGain.gain.setTargetAtTime(0.0001, now, 0.05);
            voice.oscillators.forEach(osc => osc.stop(now + 0.15));
        });
        activeVoices.clear();
    };
    
    // â”€â”€â”€ Update from preset â”€â”€â”€
    const updateFromPreset = (p: OrganPreset) => {
        // Filters
        lpf.frequency.setTargetAtTime(p.lpf ?? 5000, ctx.currentTime, 0.05);
        hpf.frequency.setTargetAtTime(p.hpf ?? 60, ctx.currentTime, 0.05);
        
        // Vibrato
        if (p.vibrato?.type && p.vibrato.type !== 'off') {
            vibrato.setType(p.vibrato.type);
            vibratoBypass.gain.value = 0;
            vibratoWet.gain.value = 1;
        } else {
            vibratoBypass.gain.value = 1;
            vibratoWet.gain.value = 0;
        }
        if (p.vibrato?.rate) {
            vibrato.setRate(p.vibrato.rate);
        }
        
        // Leslie
        if (p.leslie?.on !== false) {
            leslie.setMode(p.leslie?.mode ?? 'slow');
            leslieBypass.gain.value = 0;
            leslieWet.gain.value = 1;
            if (p.leslie?.mix !== undefined) {
                leslie.setMix(p.leslie.mix);
            }
        } else {
            leslieBypass.gain.value = 1;
            leslieWet.gain.value = 0;
        }
        
        // Reverb
        reverbWet.gain.value = p.reverbMix ?? 0.15;
        
        // Volume
        if (p.volume !== undefined) {
            instrumentGain.gain.setTargetAtTime(p.volume, ctx.currentTime, 0.02);
        }
        
        // Tonewheel character
        if (p.tonewheel) {
            tonewheelWave = createTonewheelWave(ctx, p.tonewheel);
        }
        
        // Key click
        if (p.keyClick !== undefined) {
            clickBuffer = createKeyClick(ctx, 0.008, p.keyClick);
        }
    };
    
    // â”€â”€â”€ API â”€â”€â”€
    const api = {
        noteOn,
        noteOff,
        allNotesOff,
        
        connect: (dest?: AudioNode) => master.connect(dest || output),
        disconnect: () => { try { master.disconnect(); } catch {} },
        
        setPreset: (p: OrganPreset) => {
            allNotesOff();
            currentPreset = { ...p };
            updateFromPreset(currentPreset);
        },
        
        setParam: (key: string, value: any) => {
            switch (key) {
                case 'leslie':
                    leslie.setMode(value);
                    break;
                case 'leslieMix':
                    leslie.setMix(value);
                    break;
                case 'vibrato':
                    vibrato.setType(value);
                    break;
                case 'vibratoRate':
                    vibrato.setRate(value);
                    break;
                case 'lpf':
                    lpf.frequency.setTargetAtTime(value, ctx.currentTime, 0.02);
                    break;
                case 'volume':
                    instrumentGain.gain.setTargetAtTime(value, ctx.currentTime, 0.02);
                    break;
                case 'expression':
                    expressionGain.gain.setTargetAtTime(value, ctx.currentTime, 0.01);
                    break;
                case 'drawbars':
                    currentPreset.drawbars = value;
                    break;
            }
        },
        
        setVolume: (v: number) => {
            instrumentGain.gain.setTargetAtTime(clamp(v, 0, 1), ctx.currentTime, 0.02);
        },
        getVolume: () => instrumentGain.gain.value,
        setExpression: (v: number) => {
            expressionGain.gain.setTargetAtTime(clamp(v, 0, 1), ctx.currentTime, 0.01);
        },
        
        // Leslie shortcuts
        setLeslie: (mode: 'stop' | 'slow' | 'fast') => leslie.setMode(mode),
        toggleLeslie: () => {
            const current = leslie.getMode();
            leslie.setMode(current === 'fast' ? 'slow' : 'fast');
        },
        
        // Drawbar control
        setDrawbar: (index: number, value: number) => {
            if (currentPreset.drawbars && index >= 0 && index < 9) {
                currentPreset.drawbars[index] = clamp(value, 0, 8);
            }
        },
        getDrawbars: () => [...(currentPreset.drawbars || [])],
        
        preset: currentPreset,
        type: 'organ' as const
    };
    
    console.log('%c[OrganEngine] Ready!', 'color: #32CD32; font-weight: bold;');
    return api;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTEGRATION INTO MAIN FACTORY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ ÑÑ‚Ğ¾Ñ‚ Ğ±Ğ»Ğ¾Ğº Ğ² buildMultiInstrument():

/*
else if (type === 'organ') {
    const organApi = await buildOrganEngine(ctx, preset as OrganPreset, {
        output: master,
        plateIRUrl
    });
    
    // Map organ API to standard API
    api.noteOn = organApi.noteOn;
    api.noteOff = organApi.noteOff;
    api.allNotesOff = organApi.allNotesOff;
    api.setPreset = organApi.setPreset;
    api.setParam = organApi.setParam;
    api.setVolume = organApi.setVolume;
    api.getVolume = organApi.getVolume;
    api.setExpression = organApi.setExpression;
    
    // Organ-specific
    (api as any).setLeslie = organApi.setLeslie;
    (api as any).toggleLeslie = organApi.toggleLeslie;
    (api as any).setDrawbar = organApi.setDrawbar;
    (api as any).getDrawbars = organApi.getDrawbars;
}
*/
```

---

## ĞŸÑ€ĞµÑĞµÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ°

```typescript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORGAN PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const ORGAN_PRESETS = {
    
    // â”€â”€â”€ Classic Gospel / Rock â”€â”€â”€
    organ_full: {
        type: 'organ' as const,
        volume: 0.7,
        drawbars: [8, 8, 8, 6, 0, 0, 0, 0, 0],  // Full and rich
        vibrato: { type: 'C3' as const, rate: 6.5 },
        leslie: { on: true, mode: 'slow' as const, slow: 0.8, fast: 6.5, accel: 0.8, mix: 0.75 },
        percussion: { on: true, harmonic: '2nd' as const, decay: 'fast' as const, volume: 'normal' as const },
        keyClick: 0.005,
        tonewheel: { crosstalk: 0.03, leakage: 0.02, complexity: 0.4 },
        lpf: 6000,
        hpf: 50,
        reverbMix: 0.18,
        adsr: { a: 0.004, d: 0.1, s: 0.95, r: 0.08 }
    },
    
    // â”€â”€â”€ Soft Jazz (Ñ‚Ñ‘Ğ¿Ğ»Ñ‹Ğ¹, Ğ¾ĞºÑ€ÑƒĞ³Ğ»Ñ‹Ğ¹) â”€â”€â”€
    organ_soft_jazz: {
        type: 'organ' as const,
        volume: 0.55,
        drawbars: [8, 4, 8, 4, 0, 0, 0, 0, 0],  // ĞœĞµĞ½ÑŒÑˆĞµ Ğ²ĞµÑ€Ñ…Ğ½Ğ¸Ñ… Ğ³Ğ°Ñ€Ğ¼Ğ¾Ğ½Ğ¸Ğº
        vibrato: { type: 'C2' as const, rate: 5.5 },  // ĞœÑĞ³ĞºĞ¾Ğµ Ğ²Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¾
        leslie: { on: true, mode: 'slow' as const, slow: 0.5, fast: 5.5, accel: 1.0, mix: 0.65 },
        percussion: { on: false, harmonic: '2nd' as const, decay: 'slow' as const, volume: 'soft' as const },
        keyClick: 0,  // Ğ‘ĞµĞ· ĞºĞ»Ğ¸ĞºĞ°
        tonewheel: { crosstalk: 0.01, leakage: 0.005, complexity: 0.15 },  // Ğ§Ğ¸Ñ‰Ğµ
        lpf: 3500,    // Ğ¡Ğ¸Ğ»ÑŒĞ½Ğ¾ ÑÑ€ĞµĞ·Ğ°ĞµĞ¼ Ğ²ĞµÑ€Ñ…Ğ° â€” Ñ‚ĞµĞ¿Ğ»Ğ¾!
        hpf: 50,
        reverbMix: 0.25,
        adsr: { a: 0.025, d: 0.3, s: 0.9, r: 0.35 }  // ĞœÑĞ³ĞºĞ°Ñ Ğ°Ñ‚Ğ°ĞºĞ°
    },
    
    // â”€â”€â”€ Ballad (ĞµÑ‰Ñ‘ Ğ¼ÑĞ³Ñ‡Ğµ) â”€â”€â”€
    organ_ballad: {
        type: 'organ' as const,
        volume: 0.5,
        drawbars: [8, 3, 6, 2, 0, 0, 0, 0, 0],
        vibrato: { type: 'C1' as const, rate: 5.0 },
        leslie: { on: true, mode: 'slow' as const, slow: 0.35, fast: 4.5, accel: 1.2, mix: 0.55 },
        percussion: { on: false, harmonic: '2nd' as const, decay: 'slow' as const, volume: 'soft' as const },
        keyClick: 0,
        tonewheel: { crosstalk: 0.005, leakage: 0.002, complexity: 0.08 },
        lpf: 2800,
        hpf: 45,
        reverbMix: 0.32,
        adsr: { a: 0.04, d: 0.4, s: 0.88, r: 0.5 }
    },
    
    // â”€â”€â”€ Gospel / Soul â”€â”€â”€
    organ_gospel: {
        type: 'organ' as const,
        volume: 0.72,
        drawbars: [8, 8, 6, 8, 0, 6, 0, 4, 0],  // Ğ‘Ğ¾Ğ»ÑŒÑˆĞµ Ğ¾Ğ±ĞµÑ€Ñ‚Ğ¾Ğ½Ğ¾Ğ²
        vibrato: { type: 'C3' as const, rate: 6.8 },
        leslie: { on: true, mode: 'fast' as const, slow: 0.9, fast: 7.0, accel: 0.6, mix: 0.8 },
        percussion: { on: true, harmonic: '3rd' as const, decay: 'fast' as const, volume: 'normal' as const },
        keyClick: 0.006,
        tonewheel: { crosstalk: 0.04, leakage: 0.025, complexity: 0.5 },
        lpf: 7000,
        hpf: 60,
        reverbMix: 0.2,
        adsr: { a: 0.003, d: 0.08, s: 0.95, r: 0.06 }
    },
    
    // â”€â”€â”€ Jimmy Smith Style â”€â”€â”€
    organ_jimmy_smith: {
        type: 'organ' as const,
        volume: 0.65,
        drawbars: [8, 8, 8, 0, 0, 0, 0, 0, 0],  // 888000000 â€” ĞºĞ»Ğ°ÑÑĞ¸ĞºĞ°
        vibrato: { type: 'C3' as const, rate: 6.5 },
        leslie: { on: true, mode: 'slow' as const, slow: 0.7, fast: 6.2, accel: 0.7, mix: 0.7 },
        percussion: { on: true, harmonic: '2nd' as const, decay: 'fast' as const, volume: 'soft' as const },
        keyClick: 0.004,
        tonewheel: { crosstalk: 0.025, leakage: 0.015, complexity: 0.35 },
        lpf: 5500,
        hpf: 55,
        reverbMix: 0.15,
        adsr: { a: 0.005, d: 0.12, s: 0.92, r: 0.1 }
    },
    
    // â”€â”€â”€ Progrock (Yes, ELP style) â”€â”€â”€
    organ_prog: {
        type: 'organ' as const,
        volume: 0.75,
        drawbars: [8, 6, 8, 8, 4, 5, 3, 2, 0],  // ĞœĞ½Ğ¾Ğ³Ğ¾ Ğ³Ğ°Ñ€Ğ¼Ğ¾Ğ½Ğ¸Ğº
        vibrato: { type: 'V3' as const, rate: 7.0 },  // Ğ¡Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ²Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¾
        leslie: { on: true, mode: 'fast' as const, slow: 1.0, fast: 7.5, accel: 0.5, mix: 0.85 },
        percussion: { on: true, harmonic: '3rd' as const, decay: 'slow' as const, volume: 'normal' as const },
        keyClick: 0.007,
        tonewheel: { crosstalk: 0.05, leakage: 0.03, complexity: 0.6 },
        lpf: 8000,
        hpf: 70,
        reverbMix: 0.22,
        adsr: { a: 0.003, d: 0.06, s: 0.98, r: 0.05 }
    }
};

// Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ² V2_PRESETS:
// ...ORGAN_PRESETS
```

---

## Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

```typescript
// Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ° Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ
const organ = await buildOrganEngine(audioCtx, ORGAN_PRESETS.organ_soft_jazz, {
    plateIRUrl: '/ir/plate-reverb.wav'
});

// Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ
organ.noteOn(60);                    // Middle C
organ.noteOn(64);                    // E
organ.noteOn(67);                    // G
organ.noteOff(60);

// Leslie control (Ğ¶Ğ¸Ğ²Ğ¾Ğµ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ!)
organ.setLeslie('fast');             // Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹
organ.setLeslie('slow');             // ĞœĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹
organ.toggleLeslie();                // ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ

// Drawbars Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
organ.setDrawbar(0, 8);              // 16' Ğ½Ğ° Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼
organ.setDrawbar(3, 4);              // 4' Ğ½Ğ° Ğ¿Ğ¾Ğ»Ğ¾Ğ²Ğ¸Ğ½Ñƒ
console.log(organ.getDrawbars());    // [8, 4, 8, 4, 0, 0, 0, 0, 0]

// ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹
organ.setParam('vibrato', 'C3');
organ.setParam('lpf', 4000);
organ.setVolume(0.6);
organ.setExpression(0.8);
```

---

## Ğ¨Ğ¿Ğ°Ñ€Ğ³Ğ°Ğ»ĞºĞ° Ğ¿Ğ¾ drawbars

| ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ | Footage | Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» | Ğ¥Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€ |
|---------|---------|----------|----------|
| 0 | 16' | Sub-Ğ¾ĞºÑ‚Ğ°Ğ²Ğ° | Ğ“Ğ»ÑƒĞ±Ğ¾ĞºĞ¸Ğ¹ Ğ±Ğ°Ñ |
| 1 | 5â…“' | ĞšĞ²Ğ¸Ğ½Ñ‚Ğ° | "ĞĞ¾ÑĞ¾Ğ²Ğ¾Ğ¹" |
| 2 | 8' | Ğ£Ğ½Ğ¸ÑĞ¾Ğ½ | **ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ‚Ğ¾Ğ½** |
| 3 | 4' | ĞĞºÑ‚Ğ°Ğ²Ğ° | Ğ¯Ñ€ĞºĞ¾ÑÑ‚ÑŒ |
| 4 | 2â…”' | ĞĞºÑ‚Ğ°Ğ²Ğ°+ĞºĞ²Ğ¸Ğ½Ñ‚Ğ° | "ĞšĞ²Ğ°Ñ€ĞºĞ¾Ğ²Ñ‹Ğ¹" |
| 5 | 2' | 2 Ğ¾ĞºÑ‚Ğ°Ğ²Ñ‹ | Ğ ĞµĞ·ĞºĞ¾ÑÑ‚ÑŒ |
| 6 | 1â…—' | 2 Ğ¾ĞºÑ‚ + Ñ‚ĞµÑ€Ñ†Ğ¸Ñ | ĞŸÑ€Ğ¾Ğ½Ğ·Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ |
| 7 | 1â…“' | 2 Ğ¾ĞºÑ‚ + ĞºĞ²Ğ¸Ğ½Ñ‚Ğ° | ĞÑ‡ĞµĞ½ÑŒ Ñ€ĞµĞ·ĞºĞ¸Ğ¹ |
| 8 | 1' | 3 Ğ¾ĞºÑ‚Ğ°Ğ²Ñ‹ | Ğ¡Ğ²Ğ¸ÑÑ‚ |

**Soft Jazz:** `[8,4,8,4,0,0,0,0,0]` â€” ÑƒĞ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ²ÑÑ‘ Ğ²Ñ‹ÑˆĞµ 4'  
**Gospel:** `[8,8,6,8,0,6,0,4,0]` â€” Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ²ÑĞµĞ³Ğ¾  
**Clean:** `[0,0,8,0,0,0,0,0,0]` â€” Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 8' (Ñ‡Ğ¸ÑÑ‚Ñ‹Ğ¹ ÑĞ¸Ğ½ÑƒÑ)

Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¾Ñ€Ğ³Ğ°Ğ½ Ğ·Ğ²ÑƒÑ‡Ğ¸Ñ‚ Ñ‚ĞµĞ¿Ğ»Ğ¾ Ğ¸ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ‡Ğ½Ğ¾! ğŸ¹âœ¨
