Технический анализ архитектуры проекта "AuraGroove"
=====================================================

Этот документ описывает фактическую архитектуру и поток данных в приложении, основанный на анализе исходного кода.

### Основные компоненты и их роли

Архитектура четко разделена на 5 логических уровней, каждый со своей зоной ответственности.

**1. Композитор (Условно `FractalMusicEngine`)**
*   **Роль:** Мозг всей системы. Это самый высокий уровень абстракции, отвечающий за создание музыки.
*   **Функционал:** Генерирует не просто ноты, а целостные музыкальные события (`FractalEvent`). Для каждого события он определяет не только высоту (`note`) и длительность (`duration`), но и точные инструкции по исполнению в виде объекта `params`. Этот объект содержит низкоуровневые параметры синтеза (cutoff, resonance, distortion и т.д.), фактически "запекая" в себя пресет, технику и манеру исполнения.
*   **Расположение:** Логика находится в `ambient.worker.ts` и, предположительно, в отсутствующем файле `fractal-music-engine.ts`.

**2. Дирижер (`ambient.worker.ts`)**
*   **Роль:** Управляет глобальным временем и темпом.
*   **Функционал:** Работает в отдельном потоке (Web Worker), чтобы не блокировать основной поток UI. Он запрашивает у "Композитора" партитуру (`SCORE`) на следующий такт и отправляет ее "Диспетчеру" в основном потоке через сообщение `SCORE_READY`.
*   **Расположение:** `src/app/ambient.worker.ts`

**3. Диспетчер (`audio-engine-context.tsx`)**
*   **Роль:** Центральный координационный узел на стороне клиента.
*   **Функционал:**
    *   Инициализирует всю аудиосистему (`AudioContext`, "микшер" из `GainNode`, "Менеджеров").
    *   Принимает сообщение `SCORE_READY` от "Дирижера".
    *   Выполняет роль маршрутизатора: итерируется по массиву `events` и распределяет их по соответствующим "Менеджерам" инструментов (`bassManager`, `drumMachine`, и т.д.) в зависимости от `event.type`.
    *   Отвечает за точное планирование (`scheduling`) событий во времени, передавая "Менеджерам" абсолютное время начала такта.
*   **Расположение:** `src/contexts/audio-engine-context.tsx`

**4. Менеджеры (например, `bass-synth-manager.ts`)**
*   **Роль:** Мост между абстрактными данными партитуры и конкретными "Исполнителями".
*   **Функционал:**
    *   Получает от "Диспетчера" массив событий (`FractalEvent[]`) для своей партии.
    *   Трансформирует относительное время событий в абсолютное время `AudioContext`.
    *   Преобразует `FractalEvent` в формат сообщения, понятный "Исполнителю" (`AudioWorklet`).
    *   **Ключевой момент:** Он не применяет логику пресетов или техник. Он просто копирует объект `params` из `FractalEvent` в сообщение для "Исполнителя". Функции `setPreset` и `setTechnique` в текущей реализации намеренно оставлены пустыми.
*   **Расположение:** Файлы вида `src/lib/*-manager.ts`

**5. Исполнители (например, `bass-processor.js`)**
*   **Роль:** Низкоуровневый генератор звука.
*   **Функционал:**
    *   Работает в `AudioWorklet` — отдельном аудио-потоке с высоким приоритетом, что гарантирует плавность звука.
    *   Получает от "Менеджера" сообщения (`noteOn`, `noteOff`), содержащие готовые параметры синтеза (`params`).
    *   Для каждой ноты в реальном времени генерирует звуковые сэмплы, применяя осцилляторы, огибающие, фильтры и эффекты в соответствии с полученными `params`.
    *   Не имеет никакого представления о "пресетах", "техниках" или "стилях". Он оперирует только цифрами: частота, громкость, срез фильтра и т.д.
*   **Расположение:** Файлы вида `public/worklets/*-processor.js`

### Поток модификаторов: Ожидание vs. Реальность

Существует расхождение между ожидаемой иерархией модификаторов (Пресет -> Техника) и фактической реализацией.

*   **Ожидание:** "Композитор" отдает приказ "Нота G1, техника glide". "Менеджер" применяет к текущему пресету модификатор "glide" и вычисляет итоговые параметры.
*   **Реальность:** Вся эта логика инкапсулирована внутри "Композитора". Он сам вычисляет, что для "Ноты G1 с техникой glide" в рамках текущего стиля нужны параметры `{ cutoff: 450, resonance: 0.8 }` и отдает "Менеджеру" уже готовый `params`. "Менеджер" и "Исполнитель" просто выполняют этот приказ.

### Режимы работы (`composerControlsInstruments`)

*   **`true` (Автоматический режим):** "Композитор" полностью контролирует тембр каждой ноты, присылая уникальный `params` для каждого `FractalEvent`. Ручной выбор пресета или техники через UI игнорируется на уровне "Менеджера".
*   **`false` (Ручной режим):** "Композитор" все еще генерирует `params`, но "Диспетчер" (после внесения изменений) может перехватывать их и очищать, давая "Менеджеру" команду использовать вместо них пресет, выбранный пользователем вручную.

### Заключение

Архитектура проекта является современной, производительной и хорошо структурированной. Она эффективно разделяет задачи между разными потоками (UI, Worker, AudioWorklet), что является золотым стандартом для веб-аудио приложений.

Ключевая особенность текущей реализации — **максимальная централизация музыкального "интеллекта" в "Композиторе"**. Это делает нижние уровни (Менеджеры, Исполнители) очень простыми и предсказуемыми, но переносит всю сложность в "черный ящик" генеративного движка.
