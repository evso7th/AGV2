{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents an individual user within the AuraGroove V2 application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "The user's email address, used for identification.",
          "format": "email"
        },
        "displayName": {
          "type": "string",
          "description": "The name chosen by the user for display purposes."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the user account was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the user account was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "email",
        "displayName",
        "createdAt",
        "updatedAt"
      ]
    },
    "Prompt": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Prompt",
      "type": "object",
      "description": "Represents a user's input prompt used to generate content via the AI model.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Prompt entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who created this prompt. (Relationship: User 1:N Prompt)"
        },
        "text": {
          "type": "string",
          "description": "The actual text of the user's prompt."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the prompt was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the prompt was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "text",
        "createdAt",
        "updatedAt"
      ]
    },
    "GeneratedContent": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GeneratedContent",
      "type": "object",
      "description": "Represents content ideas generated by the AI model based on a user's prompt.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the GeneratedContent entity."
        },
        "promptId": {
          "type": "string",
          "description": "Reference to the Prompt that initiated this content generation. (Relationship: Prompt 1:N GeneratedContent)"
        },
        "content": {
          "type": "string",
          "description": "The AI-generated content or idea, typically in text format."
        },
        "contentType": {
          "type": "string",
          "description": "The type or format of the generated content (e.g., 'text', 'outline', 'concept')."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the content was generated.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the generated content was last updated (e.g., by manual refinement)."
        }
      },
      "required": [
        "id",
        "promptId",
        "content",
        "contentType",
        "createdAt",
        "updatedAt"
      ]
    },
    "ContentEvaluation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContentEvaluation",
      "type": "object",
      "description": "Records user feedback (like/dislike) or AI arbitrator decisions on generated content.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ContentEvaluation entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who performed the evaluation (if user-initiated). Can be null if it's an automated AI arbitrator decision. (Relationship: User 1:N ContentEvaluation)"
        },
        "generatedContentId": {
          "type": "string",
          "description": "Reference to the GeneratedContent that was evaluated. (Relationship: GeneratedContent 1:N ContentEvaluation)"
        },
        "evaluationType": {
          "type": "string",
          "description": "The type of evaluation (e.g., 'like', 'dislike', 'arbitratorSelection')."
        },
        "decision": {
          "type": "string",
          "description": "The outcome of the evaluation (e.g., 'liked', 'disliked', 'accepted', 'rejected')."
        },
        "comment": {
          "type": "string",
          "description": "Optional comment or justification for the evaluation, especially for arbitrator selections."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the evaluation was recorded.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "generatedContentId",
        "evaluationType",
        "decision",
        "createdAt"
      ]
    },
    "Asset": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Asset",
      "type": "object",
      "description": "Represents an image, geometric shape, or other reusable media file uploaded by a user or provided by the system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Asset entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who uploaded or owns this asset. (Relationship: User 1:N Asset)"
        },
        "name": {
          "type": "string",
          "description": "A descriptive name for the asset, e.g., 'My_Image.png', 'Red Rectangle'."
        },
        "assetType": {
          "type": "string",
          "description": "The type of the asset (e.g., 'image', 'shape')."
        },
        "url": {
          "type": "string",
          "description": "The URL where the asset is stored (e.g., cloud storage URL). Required for image assets.",
          "format": "uri"
        },
        "metadata": {
          "type": "string",
          "description": "Additional JSON-serialized metadata about the asset (e.g., image dimensions, shape SVG path data)."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the asset was created or uploaded.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the asset's metadata was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "name",
        "assetType",
        "createdAt",
        "updatedAt"
      ]
    },
    "Project": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Project",
      "type": "object",
      "description": "Represents a user's creative canvas or document where content is arranged and edited.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Project entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who owns this project. (Relationship: User 1:N Project)"
        },
        "title": {
          "type": "string",
          "description": "The title of the project."
        },
        "description": {
          "type": "string",
          "description": "An optional description of the project."
        },
        "generatedContentId": {
          "type": "string",
          "description": "Optional reference to the GeneratedContent that served as the starting point for this project. (Relationship: GeneratedContent 1:N Project)"
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the project was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the project was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "title",
        "createdAt",
        "updatedAt"
      ]
    },
    "Component": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Component",
      "type": "object",
      "description": "Represents an individual element (text, image, shape) placed on a Project's canvas.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Component entity."
        },
        "projectId": {
          "type": "string",
          "description": "Reference to the Project this component belongs to. (Relationship: Project 1:N Component)"
        },
        "componentType": {
          "type": "string",
          "description": "The type of component (e.g., 'text', 'image', 'shape')."
        },
        "x": {
          "type": "number",
          "description": "The x-coordinate position of the component on the canvas."
        },
        "y": {
          "type": "number",
          "description": "The y-coordinate position of the component on the canvas."
        },
        "width": {
          "type": "number",
          "description": "The width of the component on the canvas."
        },
        "height": {
          "type": "number",
          "description": "The height of the component on the canvas."
        },
        "zIndex": {
          "type": "number",
          "description": "The stacking order (z-index) of the component, determining its visual layer."
        },
        "textContent": {
          "type": "string",
          "description": "The actual text content, if the componentType is 'text'."
        },
        "assetId": {
          "type": "string",
          "description": "Optional reference to an Asset if the componentType is 'image' or 'shape'. (Relationship: Asset 1:N Component)"
        },
        "styles": {
          "type": "string",
          "description": "JSON-serialized string of visual styles (e.g., font size, color) applied to the component."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the component was created.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp when the component was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "projectId",
        "componentType",
        "x",
        "y",
        "width",
        "height",
        "zIndex",
        "createdAt",
        "updatedAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Root collection for user profiles. Access is typically restricted to the authenticated user matching the 'userId' in the path. No denormalized authorization fields are strictly required as 'userId' is inherent to the path and document.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user, matching `request.auth.uid`."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/prompts/{promptId}",
        "definition": {
          "entityName": "Prompt",
          "schema": {
            "$ref": "#/backend/entities/Prompt"
          },
          "description": "Subcollection for prompts created by a specific user. Ownership is enforced by the parent path's 'userId'. Document must contain 'userId' field matching the path parameter.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns this prompt, matching `request.auth.uid`."
            },
            {
              "name": "promptId",
              "description": "The unique identifier for the prompt."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/prompts/{promptId}/generatedContent/{generatedContentId}",
        "definition": {
          "entityName": "GeneratedContent",
          "schema": {
            "$ref": "#/backend/entities/GeneratedContent"
          },
          "description": "Subcollection for AI-generated content linked to a specific prompt. Ownership is derived from the parent path's 'userId'. For authorization independence and simpler rules, documents in this collection SHOULD include a denormalized 'ownerUserId' field that matches the '{userId}' path parameter (the creator of the parent prompt).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns the parent prompt and this generated content, matching `request.auth.uid`."
            },
            {
              "name": "promptId",
              "description": "The unique identifier for the parent prompt."
            },
            {
              "name": "generatedContentId",
              "description": "The unique identifier for the AI-generated content."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/assets/{assetId}",
        "definition": {
          "entityName": "Asset",
          "schema": {
            "$ref": "#/backend/entities/Asset"
          },
          "description": "Subcollection for assets (images, shapes) uploaded or owned by a specific user. Ownership is enforced by the parent path's 'userId'. Document must contain 'userId' field matching the path parameter.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns this asset, matching `request.auth.uid`."
            },
            {
              "name": "assetId",
              "description": "The unique identifier for the asset."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/projects/{projectId}",
        "definition": {
          "entityName": "Project",
          "schema": {
            "$ref": "#/backend/entities/Project"
          },
          "description": "Subcollection for projects created by a specific user. Ownership is enforced by the parent path's 'userId'. Document must contain 'userId' field matching the path parameter.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns this project, matching `request.auth.uid`."
            },
            {
              "name": "projectId",
              "description": "The unique identifier for the project."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/projects/{projectId}/components/{componentId}",
        "definition": {
          "entityName": "Component",
          "schema": {
            "$ref": "#/backend/entities/Component"
          },
          "description": "Subcollection for individual components within a user's project. Ownership is derived from the parent path's 'userId'. For authorization independence and simpler rules, documents in this collection SHOULD include a denormalized 'ownerUserId' field that matches the '{userId}' path parameter (the creator of the parent project).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns the parent project and this component, matching `request.auth.uid`."
            },
            {
              "name": "projectId",
              "description": "The unique identifier for the parent project."
            },
            {
              "name": "componentId",
              "description": "The unique identifier for the component."
            }
          ]
        }
      },
      {
        "path": "/contentEvaluations/{evaluationId}",
        "definition": {
          "entityName": "ContentEvaluation",
          "schema": {
            "$ref": "#/backend/entities/ContentEvaluation"
          },
          "description": "Root collection for all content evaluations, including user likes/dislikes and AI arbitrator decisions. For Authorization Independence and queryability, each document MUST include a denormalized 'ownerUserId' (the ID of the user who owns the prompt/generated content being evaluated) and 'evaluatorUserId' (the 'userId' field in the schema, which can be null for AI arbitrators). This structure facilitates QAPs by allowing direct queries for evaluations related to content owned by `request.auth.uid`.",
          "params": [
            {
              "name": "evaluationId",
              "description": "The unique identifier for the content evaluation."
            }
          ]
        }
      },
      {
        "path": "/globalRoles/arbitrators/{arbitratorUid}",
        "definition": {
          "entityName": "ArbitratorRole",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Dedicated collection for defining users or service accounts that have the 'AI Arbitrator' role. This implements DBAC (Database-Backed Access Control). Documents here can be empty or contain minimal data; their existence grants the role to the 'arbitratorUid'. Used for authorizing AI-driven content evaluations (where `ContentEvaluation.userId` is null).",
          "params": [
            {
              "name": "arbitratorUid",
              "description": "The unique identifier (UID) of the user or service account designated as an AI arbitrator."
            }
          ]
        }
      }
    ],
    "reasoning": "The recommended Firestore structure addresses the reported 'Missing or insufficient permissions' errors by rigorously applying the core design principles, especially Authorization Independence via denormalization and Structural Segregation.\n\n**Justification for Authorization Independence & Denormalization (Mandate A):**\n1.  **Elimination of `get()` calls in Security Rules:** The primary cause of 'Missing or insufficient permissions' and transaction failures (like the 'isolated session' error) often stems from security rules that rely on `get()` operations to check parent document data. This design meticulously avoids such dependencies.\n2.  **Explicit `ownerUserId`:** For entities that are conceptually owned by a user but are either nested or exist in a root collection, we explicitly denormalize the `ownerUserId` into the document itself. This is applied to:\n    *   `GeneratedContent`: While nested under `/users/{userId}/prompts/{promptId}`, having `ownerUserId` directly in `GeneratedContent` (which is inherited from the `Prompt`'s creator) allows for more flexible and direct security checks on the `GeneratedContent` document without needing to `get()` its parent `Prompt` if `GeneratedContent` was ever to be queried or accessed independently.\n    *   `Component`: Similarly, `Component` documents will carry the `ownerUserId` of the `Project`'s creator to allow for direct access checks.\n    *   `ContentEvaluation`: This is critical. `ContentEvaluation` documents are placed in a root collection (`/contentEvaluations/{evaluationId}`). To authorize reads/writes without 'get()' calls, each `ContentEvaluation` document *must* contain `ownerUserId` (the creator of the `Prompt`/`GeneratedContent` being evaluated). It also contains `evaluatorUserId` (the `userId` field) for user-initiated evaluations. This allows for atomic write operations and simple `read` rules based on `request.auth.uid == resource.data.ownerUserId`.\n\n**Justification for QAPs (Rules are not Filters):**\n1.  **Path-Based Ownership:** For `User` profiles, `Prompts`, `Assets`, `Projects`, and `Components` (all nested under `/users/{userId}`), `list` operations inherently respect `request.auth.uid`. A query like `/users/myUserId/prompts` naturally only returns content belonging to `myUserId`, satisfying QAPs as the client must already know the `userId` in the path and `request.auth.uid` must match.\n2.  **Denormalized `ownerUserId` for Root Collections:** For `ContentEvaluation` documents, which are in a root collection, the presence of `ownerUserId` allows for efficient and secure `list` queries. A user can fetch 'their' evaluations by querying `/contentEvaluations.where('ownerUserId', '==', request.auth.uid)`. The security rule would then only allow `read` access if `resource.data.ownerUserId == request.auth.uid` (or if the user has an 'arbitrator' role, as detailed below).\n\n**Justification for DBAC (No Custom Claims) & Structural Segregation:**\n1.  **Global Roles Collection:** A dedicated collection `/globalRoles/arbitrators/{arbitratorUid}` is introduced to manage AI arbitrator roles. This uses the 'Existence over Content' principle. To authorize an AI arbitrator to write an evaluation (where `ContentEvaluation.userId` is null), the security rule will simply check `exists(/databases/$(database)/documents/globalRoles/arbitrators/$(request.auth.uid))`. This is a clean, debuggable way to manage roles without custom claims.\n2.  **Single `ContentEvaluation` Collection:** Instead of segregating user and AI evaluations into different collections, they are unified in `/contentEvaluations/{evaluationId}`. This simplifies data retrieval for the owner. However, their security postures are differentiated by checking `resource.data.userId` (for user evaluations) and `request.auth.uid` against the `arbitrators` collection (for AI evaluations). This maintains clarity while reducing the number of collections.\n\nBy following these principles, the design ensures robust security rules that are easy to write, understand, and debug, directly addressing the permission errors encountered."
  }
}