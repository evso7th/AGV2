{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the AuraGroove V2 application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user.",
          "format": "uuid"
        },
        "username": {
          "type": "string",
          "description": "The user's username."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "creationDate": {
          "type": "string",
          "description": "The date and time when the user account was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "username",
        "email",
        "creationDate"
      ]
    },
    "ContentIdea": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContentIdea",
      "type": "object",
      "description": "Represents a content idea generated by the AI model.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the content idea.",
          "format": "uuid"
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who generated this content idea. (Relationship: User 1:N ContentIdea)"
        },
        "prompt": {
          "type": "string",
          "description": "The prompt used to generate the content idea."
        },
        "generatedText": {
          "type": "string",
          "description": "The text generated by the AI model."
        },
        "creationDate": {
          "type": "string",
          "description": "The date and time when the content idea was generated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "prompt",
        "generatedText",
        "creationDate"
      ]
    },
    "Canvas": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Canvas",
      "type": "object",
      "description": "Represents a canvas created and edited by the user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the canvas.",
          "format": "uuid"
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who owns this canvas. (Relationship: User 1:N Canvas)"
        },
        "name": {
          "type": "string",
          "description": "The name of the canvas."
        },
        "creationDate": {
          "type": "string",
          "description": "The date and time when the canvas was created.",
          "format": "date-time"
        },
        "lastModifiedDate": {
          "type": "string",
          "description": "The date and time when the canvas was last modified.",
          "format": "date-time"
        },
        "canvasData": {
          "type": "string",
          "description": "JSON data representing the canvas content (text, images, shapes)."
        }
      },
      "required": [
        "id",
        "userId",
        "name",
        "creationDate",
        "lastModifiedDate",
        "canvasData"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information.  Authorization is based on user ID (`request.auth.uid == userId`).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/contentIdeas/{contentIdeaId}",
        "definition": {
          "entityName": "ContentIdea",
          "schema": {
            "$ref": "#/backend/entities/ContentIdea"
          },
          "description": "Stores content ideas generated by a specific user. Authorization is based on path ownership (`request.auth.uid == userId`).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "contentIdeaId",
              "description": "The unique identifier of the content idea."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/canvases/{canvasId}",
        "definition": {
          "entityName": "Canvas",
          "schema": {
            "$ref": "#/backend/entities/Canvas"
          },
          "description": "Stores canvases created by a specific user. Authorization is based on path ownership (`request.auth.uid == userId`).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "canvasId",
              "description": "The unique identifier of the canvas."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to securely store user-generated content and content ideas within a hierarchical structure, optimizing for authorization independence, clarity, and scalability. User data is stored in a top-level `users` collection, with each user document containing their profile information. Content ideas and canvases, which are owned by individual users, are stored as subcollections under each user document (`/users/{userId}/contentIdeas` and `/users/{userId}/canvases`). This path-based ownership model provides a clear and secure way to manage access control, as Firestore security rules can easily enforce that only the authenticated user (`request.auth.uid`) can access documents within their own user path. This ensures authorization independence.  This eliminates the need for `get()` calls in security rules.  The design inherently supports the required QAPs by segregating data based on user ownership. Listing operations are secure because the rules will always scope access to the requesting user's data.  Radical consistency is promoted through semantic naming conventions (`userId` for user references, `creationDate` for timestamps) and explicit modeling of ownership."
  }
}