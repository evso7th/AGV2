rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * AuraGroove V2 Security Rules
     *
     * CORE PHILOSOPHY:
     * This ruleset implements a strict user-ownership model combined with Database-Backed Access Control (DBAC) 
     * for specialized roles like AI Arbitrators. It prioritizes Authorization Independence to prevent common 
     * "Missing or insufficient permissions" errors caused by complex rule dependencies or hidden get() calls 
     * in transactions.
     *
     * DATA STRUCTURE:
     * - Most user-specific data (Prompts, Assets, Projects) is organized hierarchically under /users/{userId}.
     * - Shared or cross-cutting data like ContentEvaluations are kept in root collections but secured 
     *   via denormalized ownership fields (ownerUserId).
     * - Global roles are managed in a dedicated /globalRoles collection for clear, auditable authorization.
     *
     * KEY SECURITY DECISIONS:
     * 1. Authorization Independence: Critical authorization fields (ownerUserId, evaluatorUserId) are 
     *    denormalized directly into documents to ensure rules are performant and atomic.
     * 2. DBAC for Roles: AI Arbitrator permissions are determined by the existence of a document in 
     *    /globalRoles/arbitrators/{uid}, avoiding the complexity of Custom Claims.
     * 3. Prototyping Flexibility: Rules strictly enforce WHO can access data, but do NOT enforce 
     *    the specific shape (schema) of the content, allowing for rapid frontend iteration.
     * 4. Immutable Identity: Relational fields used for authorization (like ownerUserId) are made 
     *    immutable after creation to prevent unauthorized document "hijacking."
     */

    // --- HELPER FUNCTIONS ---

    /** @description Checks if the user is authenticated. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** @description Checks if the current user matches the provided ID. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** @description Checks ownership for existing documents during update/delete. */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    /** @description Checks if the user is registered as an AI Arbitrator in the global roles. */
    function isArbitrator() {
      return isSignedIn() && exists(/databases/$(database)/documents/globalRoles/arbitrators/$(request.auth.uid));
    }

    /** @description Validates that the resource contains a specific ID field matching the path. */
    function matchesPath(field, pathId) {
      return request.resource.data[field] == pathId;
    }

    /** @description Ensures a field remains unchanged during an update. */
    function isUnchanged(field) {
      return request.resource.data[field] == resource.data[field];
    }

    // --- COLLECTION RULES ---

    /**
     * @description Rules for the root User profile.
     * @path /users/{userId}
     * @allow (get, list, create, update) if the user is accessing their own profile.
     * @deny (create, update) if a user attempts to modify another user's profile.
     * @principle Self-Creation and Ownership.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && matchesPath('id', userId);
      allow update: if isExistingOwner(userId) && isUnchanged('id');
      allow delete: if isExistingOwner(userId);

      /**
       * @description User's collection of AI prompts.
       * @path /users/{userId}/prompts/{promptId}
       * @allow (create) if the userId in the prompt data matches the authenticated user and path.
       * @principle Path-based ownership and relational integrity.
       */
      match /prompts/{promptId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && matchesPath('userId', userId);
        allow update: if isExistingOwner(userId) && isUnchanged('userId');
        allow delete: if isExistingOwner(userId);

        /**
         * @description Content generated by AI for a specific prompt.
         * @path /users/{userId}/prompts/{promptId}/generatedContent/{gcId}
         * @allow (list) if the user owns the parent path.
         * @principle Subcollection access via parent ownership.
         */
        match /generatedContent/{gcId} {
          allow get, list: if isOwner(userId);
          allow create: if isOwner(userId) && matchesPath('ownerUserId', userId);
          allow update: if isExistingOwner(userId) && isUnchanged('ownerUserId');
          allow delete: if isExistingOwner(userId);
        }
      }

      /**
       * @description User's uploaded assets (images, shapes).
       * @path /users/{userId}/assets/{assetId}
       * @allow (get) if the owner is signed in.
       * @principle Ownership.
       */
      match /assets/{assetId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && matchesPath('userId', userId);
        allow update: if isExistingOwner(userId) && isUnchanged('userId');
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description User's projects (creative canvases).
       * @path /users/{userId}/projects/{projectId}
       * @allow (create) if the userId field matches the authenticated user.
       * @principle Ownership.
       */
      match /projects/{projectId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && matchesPath('userId', userId);
        allow update: if isExistingOwner(userId) && isUnchanged('userId');
        allow delete: if isExistingOwner(userId);

        /**
         * @description Elements within a project.
         * @path /users/{userId}/projects/{projectId}/components/{cId}
         * @allow (create) if the user provides the correct ownerUserId.
         * @principle Relational integrity via denormalization.
         */
        match /components/{cId} {
          allow get, list: if isOwner(userId);
          allow create: if isOwner(userId) && matchesPath('ownerUserId', userId);
          allow update: if isExistingOwner(userId) && isUnchanged('ownerUserId');
          allow delete: if isExistingOwner(userId);
        }
      }
    }

    /**
     * @description Unified collection for user feedback and AI arbitrator decisions.
     * @path /contentEvaluations/{evaluationId}
     * @allow (get, list) if the user is the content owner OR is an AI arbitrator.
     * @allow (create) if the user is the evaluator OR is an AI arbitrator.
     * @deny (create) if the evaluatorUserId does not match the requester.
     * @principle Ownership and DBAC (Arbitrator Role).
     */
    match /contentEvaluations/{evaluationId} {
      allow get, list: if isSignedIn() && (isOwner(resource.data.ownerUserId) || isArbitrator());
      allow create: if isSignedIn() && (isOwner(request.resource.data.evaluatorUserId) || isArbitrator());
      allow update: if isSignedIn() && (isExistingOwner(resource.data.evaluatorUserId) || isArbitrator());
      allow delete: if isSignedIn() && (isExistingOwner(resource.data.ownerUserId) || isArbitrator());
    }

    /**
     * @description Collection defining privileged AI Arbitrator roles.
     * @path /globalRoles/arbitrators/{arbitratorUid}
     * @allow (get) if any authenticated user needs to verify a role.
     * @deny (write) to prevent self-elevation of privileges.
     * @principle DBAC (Existence over Content).
     */
    match /globalRoles/arbitrators/{arbitratorUid} {
      allow get: if isSignedIn();
      allow list: if isSignedIn(); // Allow listing for UI role checks
      allow create, update, delete: if false; // Managed via Admin/Console only
    }
  }
}