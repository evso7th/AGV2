import type { FractalEvent, Mood, Technique } from '@/types/fractal';

// === 1. ГАРМОНИЧЕСКИЙ РЕЗОНАНС ===
function harmonicResonance(note: number, mood: Mood, beatPhase: number): number {
  const scale = getScaleForMood(mood);
  const isConsonant = scale.includes(note % 12);
  
  // Акцент на тонике в сильных долях
  const isTonic = (note % 12) === scale[0];
  const onStrongBeat = [0, 2].includes(Math.floor(beatPhase) % 4);
  
  if (isTonic && onStrongBeat) return 1.0;
  if (isConsonant) return 0.8;
  return 0.3; // диссонанс разрешается только в слабых долях
}

// === 2. РИТМИЧЕСКИЙ РЕЗОНАНС ===
function rhythmicResonance(
  event: FractalEvent,
  kickTimes: number[],
  snareTimes: number[]
): number {
  const { time, duration, technique } = event;
  
  // 1. Синхрон с kick (бас и kick на одной доле = высокий резонанс)
  const nearKick = kickTimes.some(t => Math.abs(t - time) < 0.05);
  if (nearKick) return technique === 'pluck' ? 1.0 : 0.7;
  
  // 2. Избегание snare (бас не должен играть на 2 и 4)
  const nearSnare = snareTimes.some(t => Math.abs(t - time) < 0.05);
  if (nearSnare) return 0.2;
  
  // 3. Ghost notes — только в слабых долях
  if (technique === 'ghost') {
    const beat = Math.floor(time * 2) % 4; // предполагаем 120 BPM → 2 доли/сек
    return [1, 3].includes(beat) ? 0.9 : 0.4;
  }
  
  // 4. Плотность: не более 4 нот/такт
  const notesInBar = countNotesInBar(time, duration);
  return notesInBar <= 4 ? 0.85 : 0.5;
}

// === 3. ТЕХНИЧЕСКИЙ РЕЗОНАНС ===
function techniqueResonance(technique: Technique, mood: Mood, delta: number): number {
  const techniqueMap: Record<Mood, Record<Technique, number>> = {
    melancholic: {
      pluck: 1.0,
      ghost: 0.9,
      slap: 0.3,
      harmonic: 0.7
    },
    epic: {
      pluck: 0.9,
      ghost: 0.6,
      slap: 0.8,
      harmonic: 0.5
    },
    dreamy: {
      pluck: 0.8,
      ghost: 1.0,
      slap: 0.2,
      harmonic: 0.9
    },
    dark: {
      pluck: 0.9,
      ghost: 0.8,
      slap: 0.7,
      harmonic: 0.4
    }
  };
  
  const base = techniqueMap[mood][technique] || 0.5;
  
  // При высоком δ — slap допустим даже в меланхолии
  if (technique === 'slap' && delta > 0.8) return Math.min(0.7, base + 0.2);
  
  return base;
}

// === 4. ОСНОВНАЯ ФУНКЦИЯ K_ij ===
export function MelancholicMinorK(
  eventA: FractalEvent,
  eventB: FractalEvent,
  context: {
    mood: Mood;
    delta: number;
    kickTimes: number[];
    snareTimes: number[];
    beatPhase: number;
  }
): number {
  // Гармонический резонанс (относительно лада и доли)
  const harmA = harmonicResonance(eventA.note, context.mood, context.beatPhase);
  const harmB = harmonicResonance(eventB.note, context.mood, context.beatPhase);
  
  // Ритмический резонанс (взаимодействие с ударными)
  const rhythmA = rhythmicResonance(eventA, context.kickTimes, context.snareTimes);
  const rhythmB = rhythmicResonance(eventB, context.kickTimes, context.snareTimes);
  
  // Технический резонанс (соответствие техники настроению)
  const techA = techniqueResonance(eventA.technique, context.mood, context.delta);
  const techB = techniqueResonance(eventB.technique, context.mood, context.delta);
  
  // Взвешенное среднее (можно настроить веса)
  return (
    0.5 * Math.min(harmA, harmB) +
    0.3 * Math.min(rhythmA, rhythmB) +
    0.2 * Math.min(techA, techB)
  );
}

// === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===
function getScaleForMood(mood: Mood): number[] {
  const E = 4; // E в chromatic scale (C=0)
  if (mood === 'melancholic') return [E, E+2, E+3, E+5, E+7, E+9, E+10]; // E Dorian
  return [E, E+2, E+4, E+5, E+7, E+9, E+11]; // E Major
}

function countNotesInBar(time: number, duration: number): number {
  // Упрощённо: считаем, что такт = 2 сек при 120 BPM
  const barStart = Math.floor(time / 2) * 2;
  // В реальной системе здесь будет учёт всех событий в такте
  return 3; // placeholder
}
