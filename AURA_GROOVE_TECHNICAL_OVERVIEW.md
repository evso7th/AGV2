# AuraGroove: Технический обзор проекта (Финальная версия)

## 1. Ключевая архитектурная концепция: "Композитор в Воркере, Исполнители в Ворклетах"

Проект построен на асинхронной архитектуре, где логика **сочинения** музыки полностью отделена от логики **исполнения**, что обеспечивает максимальную производительность интерфейса и чистоту звука.

*   **Композитор (Web Worker - `src/app/ambient.worker.ts`):** Это "мозг" приложения. Он работает в изолированном потоке и не занимается синтезом звука. Его задача — по команде `tick` из основного потока генерировать "партитуры" в виде массивов событий `FractalEvent`. Он управляет плотностью аранжировки, гармонией и ритмом.

*   **Исполнители (AudioWorklet-процессоры - `public/worklets/*.js`):** Это "руки" приложения. Вместо ресурсоемких `Tone.js` синтезаторов в основном потоке, мы используем легковесные аудио-процессоры, работающие напрямую в выделенном аудио-потоке с максимальной производительностью. 
    *   **`bass-processor.js`:** Получает сообщения (`noteOn`, `noteOff`, `clear`) от своего менеджера и генерирует звук баса с низкой задержкой. Он полностью инкапсулирует логику синтеза осциллятора, огибающей и фильтра.

*   **Менеджеры (Основной поток - `src/lib/*-manager.ts`):** Это "дирижеры" для ворклетов и семплеров. Они служат связующим звеном между партитурой, сгенерированной Композитором, и реальным воспроизведением звука.
    *   `BassSynthManager` является фасадом, который управляет `AudioWorkletNode` для баса. Он транслирует события `FractalEvent` в точные по времени сообщения `noteOn`/`noteOff` для `bass-processor.js`.
    *   Другие менеджеры (`DrumMachine`, `AccompanimentSynthManager` и т.д.) выполняют аналогичные функции для своих партий.

## 2. Потоки данных и жизненный цикл команды

1.  **UI -> `useAudioEngine`:** Пользователь меняет настройку (например, BPM или пресет баса).
2.  **`useAudioEngine` -> `AudioEngineProvider`:** Хук вызывает соответствующий метод (`updateSettings`, `setInstrument`).
3.  **`AudioEngineProvider` -> Worker/Manager:**
    *   Для глобальных настроек (BPM, тональность) контекст отправляет команду `{ command: 'update_settings', data: ... }` в `ambient.worker.ts`.
    *   Для настроек инструмента (смена пресета баса) контекст напрямую вызывает метод у соответствующего менеджера, например, `bassManagerRef.current.setPreset('glide-bass')`.
4.  **Worker (Композитор):** Воркер обновляет свое внутреннее состояние. В следующий `tick` он генерирует партитуру (массив `FractalEvent`) уже с учетом новых глобальных настроек.
5.  **Worker -> `AudioEngineProvider`:** Воркер отправляет готовую партитуру `{ type: 'SCORE_READY', payload: { events: [...] } }` обратно.
6.  **`AudioEngineProvider` -> Менеджеры:** Контекст разбирает массив событий и делегирует их соответствующим менеджерам (`bassManager.play(...)`, `drumMachine.schedule(...)`).
7.  **Менеджеры -> Ворклеты (Исполнители):** Менеджеры форматируют события в сообщения для `AudioWorklet` и отправляют их для исполнения в точно запланированное время (`noteOn`, `noteOff`).

## 3. Архитектура управления басом: Двойной режим

Система управления басовым синтезатором была полностью переработана для обеспечения максимальной гибкости. Она может работать в двух режимах, которые определяются флагом `composerControlsInstruments` в `WorkerSettings`.

### 3.1. Режим "Автопилот" (`composerControlsInstruments: true`)

Это режим по умолчанию. Композитор (воркер) имеет полный контроль над звучанием.

*   **Логика:** Для каждого басового события (`FractalEvent`), Композитор генерирует и прикрепляет к нему объект `params`, содержащий все необходимые для синтеза параметры (например, `cutoff`, `resonance`, `distortion`).
*   **Исполнение:** `BassSynthManager` получает событие, видит в нем `params` и передает их "как есть" в `bass-processor.js` для каждой отдельной ноты. Пресет, выбранный в UI, в этом режиме **игнорируется**.
*   **Применение:** Идеально для динамичных композиций, где тембр баса должен постоянно меняться, следуя за общей музыкальной канвой.

### 3.2. Режим "Ручного управления" (`composerControlsInstruments: false`)

В этом режиме управление тембром баса полностью переходит к пользователю.

*   **Логика:**
    1.  **UI:** Пользователь выбирает пресет (например, 'Glide Bass') через интерфейс.
    2.  **`setInstrument`:** Вызывается `bassManager.setPreset('glide-bass')`. `BassSynthManager` находит соответствующий пресет в `PRESETS` и сохраняет его параметры у себя в `this.activePresetParams`.
    3.  **`AudioEngineProvider`:** При получении партитуры от воркера, `AudioEngineProvider` проверяет флаг `composerControlsInstruments`. Если он `false`, он **принудительно удаляет** свойство `params` из всех басовых `FractalEvent` перед отправкой их в `BassSynthManager`.
*   **Исполнение:** `BassSynthManager` получает басовые события без `params`. Он видит, что `event.params` отсутствует, и вместо этого подставляет параметры из сохраненного ранее `this.activePresetParams`. Таким образом, все ноты играют выбранным вручную пресетом.
*   **Применение:** Позволяет пользователю добиться консистентного, статичного звучания баса на протяжении всей композиции или для саунд-дизайна.

### 3.3. Доступные пресеты баса

Все пресеты определены в `src/lib/presets.ts`. Каждый пресет — это объект, определяющий параметры для `bass-processor.js`.

| Имя пресета | `cutoff` | `resonance` | `distortion` | `attack` | `release` | Описание |
|---|---|---|---|---|---|---|
| **`classic-bass`** | 500 | 0.5 | 0.1 | - | - | Стандартный, универсальный бас. |
| **`ambient-drone`** | 350 | 0.8 | 0.05 | 0.5 | 5.0 | Мягкий, обволакивающий, медленный бас для эмбиента. |
| **`hypnotic-drone`**| 400 | 0.9 | 0.1 | 0.4 | 4.0 | Пульсирующий, гипнотический бас с высоким резонансом. |
| **`glide-bass`** | 300 | 0.6 | 0.0 | 0.1 | 1.0 | Чистый, скользящий бас, идеален для плавных партий. |
| **`resonant-gliss`**| 600 | 0.95| 0.0 | 0.05| 1.5 | Яркий, почти "кричащий" резонансный бас. |
| **`living-riff`** | 800 | 0.7 | 0.25| 0.02| 0.8 | Агрессивный, живой бас с дисторшном для риффов. |

*Примечание: параметры `attack` и `release` в текущей версии `bass-processor` не используются и зарезервированы для будущего развития.*

## 4. Звуковые Текстуры

Для обогащения звукового ландшафта используются два типа текстур:

*   **Pads (`PadPlayer`):** Длинные, зацикленные фоновые звуки (эмбиент-пэды).
*   **Sparkles (`SparklePlayer`):** Короткие, случайные звуковые эффекты ("искорки"), которые добавляют в музыку элемент неожиданности.

## 5. Вывод

Финальная архитектура "AuraGroove" является зрелой, производительной и масштабируемой. Переход на модель `FractalEvent` и реализация двойного режима управления инструментами (автоматического и ручного) значительно повысили гибкость системы, позволяя как полностью алгоритмическое создание музыки, так и тонкую ручную настройку звучания пользователем. Это закладывает прочный фундамент для дальнейшего расширения функционала.
