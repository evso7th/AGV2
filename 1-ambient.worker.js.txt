
// This is a bundled version of the worker, it will be automatically updated.
// Do not edit this file directly.
(() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/lib/ambient.worker.ts
  var ambient_worker_exports = {};
  __export(ambient_worker_exports, {
    default: () => ambient_worker_default
  });

  // src/lib/fractal-music-engine.ts
  var PERCUSSION_SETS = {
    NEUTRAL: ["perc-001", "perc-002", "perc-005", "perc-006", "perc-013", "perc-014", "perc-015", "drum_ride", "cymbal_bell1"],
    ELECTRONIC: ["perc-003", "perc-004", "perc-007", "perc-008", "perc-009", "perc-010", "perc-011", "perc-012", "hh_bark_short"],
    DARK: ["perc-013", "drum_snare_off", "drum_tom_low", "perc-007", "perc-015"]
  };
  var ALL_RIDES = ["drum_ride", "drum_a_ride1", "drum_a_ride2", "drum_a_ride3", "drum_a_ride4"];
  var AMBIENT_SNARES = ["drum_snare_ghost_note", "drum_snarepress", "drum_snare_off"];
  var AMBIENT_PERC = [...PERCUSSION_SETS.ELECTRONIC, ...ALL_RIDES];
  function getScaleForMood(mood) {
    const E1 = 28;
    let baseScale;
    switch (mood) {
      case "joyful":
        baseScale = [0, 2, 4, 5, 7, 9, 11];
        break;
      case "epic":
      case "enthusiastic":
        baseScale = [0, 2, 4, 6, 7, 9, 11];
        break;
      case "dreamy":
        baseScale = [0, 2, 4, 7, 9];
        break;
      case "contemplative":
        baseScale = [0, 2, 4, 5, 7, 9, 10];
        break;
      case "melancholic":
      case "calm":
        baseScale = [0, 2, 3, 5, 7, 9, 10];
        break;
      case "dark":
        baseScale = [0, 2, 3, 5, 7, 8, 10];
        break;
      case "anxious":
        baseScale = [0, 1, 3, 5, 6, 8, 10];
        break;
      default:
        baseScale = [0, 2, 3, 5, 7, 8, 10];
        break;
    }
    const fullScale = [];
    for (let octave = 0; octave < 3; octave++) {
      for (const note of baseScale) {
        fullScale.push(E1 + octave * 12 + note);
      }
    }
    fullScale.push(E1 + 36);
    return fullScale;
  }
  function generateAmbientBassPhrase(mood, genre, random) {
    const phrase = [];
    const scale = getScaleForMood(mood);
    const numNotes = 5 + random.nextInt(8);
    let currentTime = 0;
    const selectNote = () => {
      const rand = random.next();
      if (rand < 0.8) {
        const half = Math.floor(scale.length / 2);
        return scale[random.nextInt(half)];
      } else {
        const half = Math.floor(scale.length / 2);
        return scale[half + random.nextInt(scale.length - half)];
      }
    };
    let currentNote = selectNote();
    for (let i = 0; i < numNotes; i++) {
      const durationRand = random.next();
      let duration;
      if (durationRand < 0.6)
        duration = 0.5;
      else if (durationRand < 0.9)
        duration = 1;
      else
        duration = 0.25;
      phrase.push({
        type: "bass",
        note: currentNote,
        duration,
        time: currentTime,
        weight: 0.7 + random.next() * 0.3,
        technique: "swell",
        dynamics: "mf",
        phrasing: "legato",
        params: { cutoff: 300, resonance: 0.8, distortion: 0.02, portamento: 0, attack: 0.2, release: duration * 1.2 }
      });
      currentTime += duration;
      const currentIndex = scale.indexOf(currentNote);
      let step = 0;
      if (random.next() < 0.85) {
        step = random.next() > 0.5 ? 1 : -1;
      } else {
        step = random.nextInt(5) - 2;
      }
      const nextIndex = Math.max(0, Math.min(scale.length - 1, currentIndex + step));
      currentNote = scale[nextIndex];
    }
    const totalDuration = phrase.reduce((sum, e) => sum + e.duration, 0);
    if (totalDuration > 4) {
      const scaleFactor = 4 / totalDuration;
      let runningTime = 0;
      phrase.forEach((e) => {
        e.duration *= scaleFactor;
        e.time = runningTime;
        runningTime += e.duration;
      });
    }
    return phrase;
  }
  function mutateBassPhrase(phrase, mood, genre, random) {
    const newPhrase = JSON.parse(JSON.stringify(phrase));
    const mutationType = random.nextInt(4);
    if (newPhrase.length === 0)
      return [];
    switch (mutationType) {
      case 0:
        const noteToChange = newPhrase[random.nextInt(newPhrase.length)];
        noteToChange.duration *= random.next() > 0.5 ? 1.5 : 0.5;
        break;
      case 1:
        const noteToTranspose = newPhrase[random.nextInt(newPhrase.length)];
        const scale = getScaleForMood(mood);
        const currentIndex = scale.indexOf(noteToTranspose.note);
        if (currentIndex !== -1) {
          const step = random.next() > 0.5 ? 1 : -1;
          const newIndex = (currentIndex + step + scale.length) % scale.length;
          noteToTranspose.note = scale[newIndex];
        }
        break;
      case 2:
        if (newPhrase.length > 2) {
          const start = random.nextInt(newPhrase.length - 2);
          const fragment = newPhrase.slice(start, start + 2);
          const reversedNotes = fragment.map((e) => e.note).reverse();
          fragment.forEach((event, i) => event.note = reversedNotes[i]);
        }
        break;
      case 3:
        if (random.next() > 0.5 && newPhrase.length > 3) {
          newPhrase.splice(random.nextInt(newPhrase.length), 1);
        } else {
          const scale2 = getScaleForMood(mood);
          const newNoteEvent = __spreadValues({}, newPhrase[0]);
          newNoteEvent.note = scale2[random.nextInt(scale2.length)];
          newNoteEvent.time = newPhrase[newPhrase.length - 1].time + newPhrase[newPhrase.length - 1].duration;
          newNoteEvent.duration = 0.5;
          newPhrase.push(newNoteEvent);
        }
        break;
    }
    let currentTime = 0;
    newPhrase.forEach((e) => {
      e.time = currentTime;
      currentTime += e.duration;
    });
    if (currentTime > 4) {
      const scaleFactor = 4 / currentTime;
      let runningTime = 0;
      newPhrase.forEach((e) => {
        e.duration *= scaleFactor;
        e.time = runningTime;
        runningTime += e.duration;
      });
    }
    return newPhrase;
  }
  var STYLE_DRUM_PATTERNS = {
    ambient: {
      loops: [
        {
          kick: [{ type: "drum_kick", time: 0, duration: 4, weight: 0.5, probability: 0.25 }],
          snare: [{ type: AMBIENT_SNARES, time: 2.5, duration: 0.5, weight: 0.3, probability: 0.15 }],
          hihat: [{ type: AMBIENT_PERC, time: 1.5, duration: 0.5, weight: 0.4, probability: 0.4 }],
          tags: ["ambient-pulse"]
        }
      ],
      percussion: {
        types: AMBIENT_PERC,
        allowedTimes: [0.75, 1.25, 1.75, 2.25, 2.75, 3.25, 3.75],
        probability: 0.6,
        weight: 0.3,
        type: "electronic"
      }
    },
    rock: {
      loops: [
        {
          kick: [{ type: "drum_kick", time: 0, duration: 0.25, weight: 1 }, { type: "drum_kick", time: 2, duration: 0.25, weight: 1 }],
          snare: [{ type: "drum_snare", time: 1, duration: 0.25, weight: 1 }, { type: ["drum_snare", "drum_snare_ghost_note"], probabilities: [0.8, 0.2], time: 3, duration: 0.25, weight: 1 }],
          hihat: [
            { type: ALL_RIDES, time: 0.5, duration: 0.5, weight: 0.6 },
            { type: ALL_RIDES, time: 1.5, duration: 0.5, weight: 0.6 },
            { type: ALL_RIDES, time: 2.5, duration: 0.5, weight: 0.6 },
            { type: ALL_RIDES, time: 3.5, duration: 0.5, weight: 0.6 }
          ],
          tags: ["rock-standard"]
        }
      ]
    },
    house: {
      loops: [
        {
          kick: [
            { type: "drum_kick", time: 0, duration: 0.25, weight: 1 },
            { type: "drum_kick", time: 1, duration: 0.25, weight: 1 },
            { type: "drum_kick", time: 2, duration: 0.25, weight: 1 },
            { type: "drum_kick", time: 3, duration: 0.25, weight: 1 }
          ],
          snare: [
            { type: ["drum_snare", "perc-004"], probabilities: [0.9, 0.1], time: 1, duration: 0.25, weight: 0.9 },
            { type: ["drum_snare", "perc-004"], probabilities: [0.9, 0.1], time: 3, duration: 0.25, weight: 0.9 }
          ],
          hihat: [
            { type: "drum_hihat_open", time: 0.5, duration: 0.5, weight: 0.8 },
            { type: "drum_hihat_open", time: 1.5, duration: 0.5, weight: 0.8 },
            { type: "drum_hihat_open", time: 2.5, duration: 0.5, weight: 0.8 },
            { type: "drum_hihat_open", time: 3.5, duration: 0.5, weight: 0.8 }
          ],
          tags: ["four-on-the-floor"]
        }
      ]
    },
    trance: {
      loops: [
        {
          kick: [
            { type: "drum_kick", time: 0, duration: 0.25, weight: 1 },
            { type: "drum_kick", time: 1, duration: 0.25, weight: 0.8, probability: 0.75 },
            { type: "drum_kick", time: 2, duration: 0.25, weight: 1 },
            { type: "drum_kick", time: 3, duration: 0.25, weight: 0.8, probability: 0.75 }
          ],
          snare: [
            { type: ["drum_snare", "perc-009"], probabilities: [0.8, 0.2], time: 2, duration: 0.25, weight: 0.9, probability: 0.5 }
            // Snare on 3rd beat
          ],
          hihat: [
            { type: "drum_hihat_open", time: 0.5, duration: 0.25, weight: 0.7 },
            { type: "drum_hihat_open", time: 1.5, duration: 0.25, weight: 0.7 },
            { type: "drum_hihat_open", time: 2.5, duration: 0.25, weight: 0.7 },
            { type: "drum_hihat_open", time: 3.5, duration: 0.25, weight: 0.7 }
          ],
          tags: ["trance-drive"]
        }
      ]
    },
    rnb: {
      loops: [
        {
          kick: [
            { type: "drum_kick", time: 0, duration: 0.25, weight: 1 },
            { type: "drum_kick", time: 1.75, duration: 0.25, weight: 0.8, probability: 0.8 }
          ],
          snare: [
            { type: ["drum_snare", "drum_snare_ghost_note"], probabilities: [0.8, 0.2], time: 1, duration: 0.25, weight: 0.9 },
            { type: "drum_snare", time: 3, duration: 0.25, weight: 1 }
          ],
          hihat: [
            { type: "drum_hihat_closed", time: 0.5, duration: 0.5, weight: 0.6 },
            { type: ["drum_hihat_closed", "hh_bark_short"], probabilities: [0.85, 0.15], time: 2.5, duration: 0.5, weight: 0.6 },
            { type: "drum_hihat_closed", time: 3.5, duration: 0.5, weight: 0.6, probability: 0.7 }
          ],
          tags: ["rnb-groove", "hip-hop"]
        }
      ]
    },
    ballad: {
      loops: [
        {
          kick: [{ type: "drum_kick", time: 0, duration: 1, weight: 0.8, probability: 0.9 }],
          snare: [{ type: "drum_snare", time: 2, duration: 1, weight: 0.7, probability: 0.9 }],
          hihat: [
            { type: ALL_RIDES, time: 0, duration: 0.5, weight: 0.5, probability: 0.8 },
            { type: ALL_RIDES, time: 1, duration: 0.5, weight: 0.5, probability: 0.8 },
            { type: ALL_RIDES, time: 2, duration: 0.5, weight: 0.5, probability: 0.8 },
            { type: ALL_RIDES, time: 3, duration: 0.5, weight: 0.5, probability: 0.8 }
          ],
          tags: ["ballad-simple"]
        }
      ]
    },
    reggae: {
      loops: [
        {
          kick: [],
          snare: [{ type: "drum_kick", time: 2, duration: 0.5, weight: 1 }],
          // Kick and snare together
          hihat: [
            { type: "drum_hihat_closed", time: 0.5, duration: 0.5, weight: 0.8 },
            { type: "drum_hihat_closed", time: 1.5, duration: 0.5, weight: 0.8 },
            { type: "drum_hihat_closed", time: 2.5, duration: 0.5, weight: 0.8 },
            { type: "drum_hihat_closed", time: 3.5, duration: 0.5, weight: 0.8 }
          ],
          tags: ["one-drop"]
        }
      ]
    },
    blues: {
      loops: [
        {
          kick: [{ type: "drum_kick", time: 0, duration: 0.5, weight: 0.9 }, { type: "drum_kick", time: 2, duration: 0.5, weight: 0.9 }],
          snare: [{ type: "drum_snare", time: 1, duration: 0.5, weight: 1 }, { type: "drum_snare", time: 3, duration: 0.5, weight: 1 }],
          hihat: [
            { type: ALL_RIDES, time: 0, duration: 0.66, weight: 0.6 },
            { type: ALL_RIDES, time: 0.66, duration: 0.33, weight: 0.4 },
            { type: ALL_RIDES, time: 1, duration: 0.66, weight: 0.6 },
            { type: ALL_RIDES, time: 1.66, duration: 0.33, weight: 0.4 },
            { type: ALL_RIDES, time: 2, duration: 0.66, weight: 0.6 },
            { type: ALL_RIDES, time: 2.66, duration: 0.33, weight: 0.4 },
            { type: ALL_RIDES, time: 3, duration: 0.66, weight: 0.6 },
            { type: ALL_RIDES, time: 3.66, duration: 0.33, weight: 0.4 }
          ],
          tags: ["shuffle"]
        }
      ]
    },
    celtic: {
      loops: [{ kick: [], snare: [], hihat: [], tags: ["bodhran-pulse"] }]
    },
    progressive: {
      loops: [
        {
          kick: [{ type: "drum_kick", time: 0, duration: 0.25, weight: 1 }],
          snare: [{ type: ["drum_snare", "drum_snare_off"], probabilities: [0.9, 0.1], time: 1, duration: 0.25, weight: 1 }, { type: "drum_snare", time: 3, duration: 0.25, weight: 1 }],
          hihat: [],
          tags: ["prog-rock-sparse"]
        }
      ]
    }
  };
  var STYLE_BASS_PATTERNS = {
    ambient: [
      { pattern: (scale, random) => generateAmbientBassPhrase("calm", "ambient", random).map((e) => ({ note: e.note, time: e.time, duration: e.duration })), tags: ["ambient-generative"] }
    ],
    rock: [
      { pattern: [{ note: 0, time: 0, duration: 0.5 }, { note: 0, time: 0.5, duration: 0.5 }, { note: 0, time: 1, duration: 0.5 }, { note: 0, time: 1.5, duration: 0.5 }, { note: 0, time: 2, duration: 0.5 }, { note: 0, time: 2.5, duration: 0.5 }, { note: 0, time: 3, duration: 0.5 }, { note: 0, time: 3.5, duration: 0.5 }], tags: ["rock-standard", "rock-eighths"] },
      { pattern: [{ note: 0, time: 0, duration: 1 }, { note: 2, time: 2, duration: 1 }, { note: 4, time: 3, duration: 1 }], tags: ["rock-standard"] }
    ],
    house: [
      { pattern: [{ note: 0, time: 0, duration: 1 }, { note: 0, time: 1, duration: 1 }, { note: 0, time: 2, duration: 1 }, { note: 0, time: 3, duration: 1 }], tags: ["four-on-the-floor"] },
      { pattern: [{ note: 0, time: 0, duration: 0.5 }, { note: 7, time: 0.5, duration: 0.5 }, { note: 0, time: 1, duration: 0.5 }, { note: 7, time: 1.5, duration: 0.5 }, { note: 0, time: 2, duration: 0.5 }, { note: 7, time: 2.5, duration: 0.5 }, { note: 0, time: 3, duration: 0.5 }, { note: 7, time: 3.5, duration: 0.5 }], tags: ["four-on-the-floor", "octave-jump"] }
    ],
    trance: [
      { pattern: [{ note: 0, time: 0, duration: 0.5 }, { note: 0, time: 0.5, duration: 0.5 }, { note: 0, time: 1, duration: 0.5 }, { note: 0, time: 1.5, duration: 0.5 }, { note: 0, time: 2, duration: 0.5 }, { note: 0, time: 2.5, duration: 0.5 }, { note: 0, time: 3, duration: 0.5 }, { note: 0, time: 3.5, duration: 0.5 }], tags: ["trance-drive"] },
      { pattern: [{ note: 0, time: 0, duration: 0.25 }, { note: 0, time: 0.75, duration: 0.25 }, { note: 0, time: 1.5, duration: 0.25 }, { note: 0, time: 2.25, duration: 0.25 }, { note: 0, time: 3, duration: 0.25 }, { note: 0, time: 3.75, duration: 0.25 }], tags: ["trance-drive", "syncopated"] }
    ],
    rnb: [
      { pattern: [{ note: 0, time: 0, duration: 1.5 }, { note: 4, time: 1.5, duration: 0.5 }, { note: 2, time: 2, duration: 1.5 }, { note: 0, time: 3.5, duration: 0.5, technique: "ghost" }], tags: ["rnb-groove"] },
      { pattern: [{ note: 0, time: 1, duration: 0.75 }, { note: 2, time: 1.75, duration: 0.75 }, { note: -1, time: 2.5, duration: 0.5 }, { note: 0, time: 3.25, duration: 0.75 }], tags: ["rnb-groove", "hip-hop"] }
    ],
    ballad: [
      { pattern: [{ note: 0, time: 0, duration: 3 }, { note: 4, time: 3, duration: 1 }], tags: ["ballad-simple"] },
      { pattern: [{ note: 0, time: 0, duration: 2 }, { note: 2, time: 2, duration: 2 }], tags: ["ballad-simple"] }
    ],
    reggae: [
      { pattern: [{ note: 0, time: 1, duration: 1 }, { note: 0, time: 3, duration: 1, technique: "ghost" }], tags: ["one-drop"] },
      { pattern: [{ note: 0, time: 2.5, duration: 1.5 }], tags: ["one-drop"] }
    ],
    blues: [
      { pattern: [{ note: 0, time: 0, duration: 1 }, { note: 2, time: 1, duration: 1 }, { note: 4, time: 2, duration: 1 }, { note: 5, time: 3, duration: 1 }], tags: ["shuffle", "walking-bass"] },
      { pattern: [{ note: 0, time: 0, duration: 0.66 }, { note: 2, time: 0.66, duration: 0.33 }, { note: 4, time: 1, duration: 0.66 }, { note: 2, time: 1.66, duration: 0.33 }], tags: ["shuffle"] }
    ],
    celtic: [
      { pattern: [{ note: 0, time: 0, duration: 1 }, { note: 4, time: 2, duration: 1 }], tags: ["bodhran-pulse"] },
      { pattern: [{ note: 0, time: 0, duration: 0.5 }, { note: 7, time: 0.5, duration: 0.5 }, { note: 0, time: 1, duration: 0.5 }, { note: 7, time: 1.5, duration: 0.5 }], tags: ["bodhran-pulse"] }
    ],
    progressive: [
      { pattern: [{ note: 0, time: 0, duration: 0.75 }, { note: 0, time: 0.75, duration: 0.25 }, { note: 2, time: 1, duration: 1 }, { note: -1, time: 2.5, duration: 1.5 }], tags: ["prog-rock-sparse", "syncopated"] }
    ]
  };

  // src/lib/resonance-matrices.ts
  function areSimultaneous(timeA, timeB) {
    return Math.abs(timeA - timeB) < 0.05;
  }
  function getBeat(timeInBeats) {
    return Math.floor(timeInBeats) % 4;
  }
  function isOnStrongBeat(timeInBeats) {
    const beat = getBeat(timeInBeats);
    return beat === 0 || beat === 2;
  }
  function isOnSnareBeat(timeInBeats) {
    const beat = getBeat(timeInBeats);
    return beat === 1 || beat === 3;
  }
  var isGhostNote = (event) => event.technique === "ghost";
  var isKick = (event) => event.type === "drum_kick";
  var isSnare = (event) => event.type === "drum_snare";
  var isBass2 = (event) => event.type === "bass";
  var isCrash = (event) => event.type === "drum_crash";
  var isFill = (event) => event.technique === "fill";
  var isTom = (event) => event.type.startsWith("drum_tom");
  var isAccompaniment = (event) => event.type === "accompaniment";
  var MelancholicMinorK = (eventA, eventB, context) => {
    if (!eventA || !eventB) {
      return 0.5;
    }
    const event1IsBass = isBass2(eventA);
    const event2IsBass = isBass2(eventB);
    const event1IsDrums = eventA.type.startsWith("drum_") || eventA.type.startsWith("perc-");
    const event2IsDrums = eventB.type.startsWith("drum_") || eventB.type.startsWith("perc-");
    const event1IsAccomp = isAccompaniment(eventA);
    const event2IsAccomp = isAccompaniment(eventB);
    if (event1IsBass && event2IsDrums || event1IsDrums && event2IsBass) {
      const bassEvent = event1IsBass ? eventA : eventB;
      const drumEvent = event1IsDrums ? eventA : eventB;
      if (isFill(bassEvent) && (isTom(drumEvent) || isSnare(drumEvent) && drumEvent.weight > 0.8)) {
        if (areSimultaneous(bassEvent.time, drumEvent.time))
          return 1;
        if (Math.abs(bassEvent.time - drumEvent.time) < 0.25)
          return 0.9;
      }
      if (isKick(drumEvent)) {
        if (areSimultaneous(bassEvent.time, drumEvent.time) && isOnStrongBeat(bassEvent.time))
          return 1;
        if (Math.abs(bassEvent.time - drumEvent.time - 0.5) < 0.1 && isOnStrongBeat(drumEvent.time))
          return 0.85;
        return 0.3;
      }
      if (isSnare(drumEvent)) {
        if (areSimultaneous(eventA.time, eventB.time) && isOnSnareBeat(eventA.time)) {
          return 0.1;
        }
        return 0.8;
      }
    }
    if (event1IsBass && event2IsAccomp || event1IsAccomp && event2IsBass) {
      const scale = getScaleForMood(context.mood);
      const noteAInScale = scale.some((scaleNote) => eventA.note % 12 === scaleNote % 12);
      const noteBInScale = scale.some((scaleNote) => eventB.note % 12 === scaleNote % 12);
      if (!noteAInScale || !noteBInScale)
        return 0.2;
      const interval = Math.abs(eventA.note - eventB.note) % 12;
      if ([3, 4, 7, 8, 9].includes(interval))
        return 0.9;
      return 0.6;
    }
    if (event1IsDrums && event2IsDrums) {
      if (isKick(eventA) && isSnare(eventB) || isSnare(eventA) && isKick(eventB)) {
        const kickTime = isKick(eventA) ? eventA.time : eventB.time;
        const snareTime = isSnare(eventA) ? eventA.time : eventB.time;
        if (isOnStrongBeat(kickTime) && isOnSnareBeat(snareTime)) {
          return 0.95;
        }
        return 0.4;
      }
    }
    if (isGhostNote(eventA) || isGhostNote(eventB)) {
      const time = isGhostNote(eventA) ? eventA.time : eventB.time;
      return !isOnStrongBeat(time) ? 0.9 : 0.2;
    }
    if (event1IsBass && event2IsBass && eventA.note !== eventB.note || event1IsAccomp && event2IsAccomp) {
      const scale = getScaleForMood(context.mood);
      const noteAInScale = scale.some((scaleNote) => eventA.note % 12 === scaleNote % 12);
      const noteBInScale = scale.some((scaleNote) => eventB.note % 12 === scaleNote % 12);
      if (isFill(eventA) && isFill(eventB)) {
        return noteAInScale && noteBInScale ? 0.95 : 0.2;
      }
      return noteAInScale && noteBInScale ? 0.9 : 0.3;
    }
    if (context.delta > 0.9) {
      if (isTom(eventA) || isTom(eventB))
        return 0.85;
      if ((isCrash(eventA) || isCrash(eventB)) && context.genre !== "ambient")
        return 1;
    } else {
      if (isCrash(eventA) || isCrash(eventB))
        return 0.05;
    }
    return 0.5;
  };

  // src/lib/fractal-music-engine.ts
  function getParamsForTechnique(technique, mood, genre) {
    switch (technique) {
      case "pluck":
        return { cutoff: 800, resonance: 0.3, distortion: 0.1, portamento: 0.01 };
      case "ghost":
        return { cutoff: 450, resonance: 0.2, distortion: 0, portamento: 0 };
      case "slap":
        return { cutoff: 1200, resonance: 0.5, distortion: 0.3, portamento: 0 };
      case "fill":
        return { cutoff: 1200, resonance: 0.6, distortion: 0.25, portamento: 0 };
      case "swell":
        return { cutoff: 300, resonance: 0.8, distortion: 0.02, portamento: 0, attack: 0.5, release: 1.5 };
      default:
        return { cutoff: 500, resonance: 0.2, distortion: 0, portamento: 0 };
    }
  }
  function seededRandom(seed) {
    let state = seed;
    const self = {
      next: () => {
        state = (state * 1664525 + 1013904223) % 2 ** 32;
        return state / 2 ** 32;
      },
      nextInt: (max) => Math.floor(self.next() * max)
    };
    return self;
  }
  function safeTime(value, fallback = 0) {
    return isFinite(value) ? value : fallback;
  }
  var isBass = (event) => event.type === "bass";
  function createDrumAxiom(genre, mood, tempo, random) {
    var _a, _b, _c, _d;
    const hitParams = getParamsForTechnique("hit", mood, genre);
    const grammar = STYLE_DRUM_PATTERNS[genre] || STYLE_DRUM_PATTERNS["ambient"];
    const loop = grammar.loops[random.nextInt(grammar.loops.length)];
    const axiomEvents = [];
    if (!loop)
      return { events: [], tags: [] };
    const allBaseEvents = [...loop.kick || [], ...loop.snare || [], ...loop.hihat || []];
    for (const baseEvent of allBaseEvents) {
      if (baseEvent.probability && random.next() > baseEvent.probability) {
        continue;
      }
      let instrumentType;
      if (Array.isArray(baseEvent.type)) {
        const types = baseEvent.type;
        const probabilities = baseEvent.probabilities || [];
        let rand = random.next();
        let cumulativeProb = 0;
        let chosenType = null;
        for (let i = 0; i < types.length; i++) {
          cumulativeProb += probabilities[i] || 1 / types.length;
          if (rand <= cumulativeProb) {
            chosenType = types[i];
            break;
          }
        }
        instrumentType = chosenType || types[types.length - 1];
      } else {
        instrumentType = baseEvent.type;
      }
      axiomEvents.push(__spreadProps(__spreadValues({}, baseEvent), {
        type: instrumentType,
        note: 36,
        // Placeholder MIDI
        phrasing: "staccato",
        dynamics: "mf",
        // Placeholder
        params: hitParams
      }));
    }
    return { events: axiomEvents, tags: loop.tags };
  }
  function createAccompanimentAxiom(mood, genre, random, bassNote) {
    const scale = getScaleForMood(mood);
    const swellParams = getParamsForTechnique("swell", mood, genre);
    const arpeggio = [];
    const rootMidi = bassNote;
    const rootDegree = rootMidi % 12;
    const findNoteInScale = (degree) => scale.find((n) => n % 12 === (degree + 12) % 12);
    const thirdDegree = findNoteInScale(rootDegree + (mood === "melancholic" || mood === "dark" ? 3 : 4));
    const fifthDegree = findNoteInScale(rootDegree + 7);
    const chord = [rootMidi, thirdDegree, fifthDegree].filter((n) => n !== void 0);
    if (chord.length < 2)
      return [];
    const pattern = [0, 1, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 2, 0, 1];
    const duration = 0.25;
    for (let i = 0; i < pattern.length; i++) {
      const time = i * duration;
      const noteMidi = chord[pattern[i] % chord.length];
      if (noteMidi) {
        arpeggio.push({
          type: "accompaniment",
          note: noteMidi,
          duration,
          time,
          weight: 0.6 + random.next() * 0.1,
          technique: "swell",
          dynamics: "p",
          phrasing: "legato",
          params: swellParams
        });
      }
    }
    return arpeggio;
  }
  function createRhythmSectionFill(mood, genre, random) {
    const hitParams = getParamsForTechnique("hit", mood, genre);
    const fillParams = getParamsForTechnique("fill", mood, genre);
    const drumFill = [];
    const bassFill = [];
    const scale = getScaleForMood(mood);
    const fillDensity = random.nextInt(3) + 2;
    let drumTime = 3;
    const drumInstruments = ["drum_tom_low", "drum_tom_mid", "drum_tom_high", "drum_snare"];
    for (let i = 0; i < fillDensity; i++) {
      const instrument = drumInstruments[random.nextInt(drumInstruments.length)];
      const duration = 1 / fillDensity;
      const currentDrumTime = drumTime;
      drumFill.push({ type: instrument, note: 41 + i, duration, time: currentDrumTime, weight: 0.7 + random.next() * 0.2, technique: "hit", dynamics: "mf", phrasing: "staccato", params: hitParams });
      if (random.next() > 0.4) {
        const noteIndex = random.nextInt(scale.length);
        bassFill.push({ type: "bass", note: scale[noteIndex], duration: duration * 0.8, time: currentDrumTime, weight: 0.7 + random.next() * 0.2, technique: "fill", dynamics: "mf", phrasing: "staccato", params: fillParams });
      }
      drumTime += duration;
    }
    drumFill.push({ type: "drum_snare", note: 38, duration: 0.25, time: 3.75, weight: 0.8 + random.next() * 0.2, technique: "hit", dynamics: "mf", phrasing: "staccato", params: hitParams });
    drumFill.push({ type: "drum_crash", note: 49, duration: 0.25, time: 3.75, weight: 0.8 + random.next() * 0.2, technique: "hit", dynamics: "mf", phrasing: "staccato", params: hitParams });
    if (random.next() > 0.3) {
      bassFill.push({ type: "bass", note: scale[0], duration: 0.25, time: 3.75, weight: 0.9, technique: "fill", dynamics: "mf", phrasing: "staccato", params: fillParams });
    }
    return { drumFill, bassFill };
  }
  function createBassFill(mood, genre, random) {
    const fill = [];
    const scale = getScaleForMood(mood);
    const fillParams = getParamsForTechnique("fill", mood, genre);
    const numNotes = random.nextInt(4) + 7;
    let currentTime = 0;
    const selectNote = () => {
      const rand = random.next();
      if (rand < 0.7) {
        const third = Math.floor(scale.length / 3);
        return scale[random.nextInt(third)];
      } else if (rand < 0.95) {
        const third = Math.floor(scale.length / 3);
        return scale[third + random.nextInt(third)];
      } else {
        const twoThirds = Math.floor(2 * scale.length / 3);
        return scale[twoThirds + random.nextInt(scale.length - twoThirds)];
      }
    };
    let currentNote = selectNote();
    let lastNote = -1;
    let secondLastNote = -1;
    for (let i = 0; i < numNotes; i++) {
      const duration = genre === "rock" || genre === "trance" || genre === "progressive" ? 0.25 : 0.5;
      let noteIndex = scale.indexOf(currentNote);
      let step;
      let attempts = 0;
      do {
        step = random.next() > 0.7 ? random.next() > 0.5 ? 2 : -2 : random.next() > 0.5 ? 1 : -1;
        let newNoteIndex = (noteIndex + step + scale.length) % scale.length;
        if (Math.abs(scale[newNoteIndex] - currentNote) > 12) {
          newNoteIndex = (noteIndex - step + scale.length) % scale.length;
        }
        currentNote = scale[newNoteIndex];
        noteIndex = newNoteIndex;
        attempts++;
      } while (currentNote === lastNote && currentNote === secondLastNote && attempts < 10);
      fill.push({
        type: "bass",
        note: currentNote,
        duration,
        time: currentTime,
        weight: 0.8 + random.next() * 0.2,
        technique: "fill",
        dynamics: "f",
        phrasing: "staccato",
        params: fillParams
      });
      currentTime += duration;
      secondLastNote = lastNote;
      lastNote = currentNote;
    }
    if (currentTime > 4) {
      const scaleFactor = 4 / currentTime;
      fill.forEach((e) => {
        e.time *= scaleFactor;
        e.duration *= scaleFactor;
      });
    }
    const highNoteThreshold = 52;
    const hasHighNotes = fill.some((n) => n.note > highNoteThreshold);
    if (hasHighNotes) {
      console.warn(`[BassFillPenalty] High-register fill detected. Applying penalty.`);
      fill.forEach((e) => e.weight *= 0.2);
      this.needsBassReset = true;
    }
    return fill;
  }
  var FractalMusicEngine = class {
    constructor(config) {
      this.config = __spreadValues({}, config);
      this.lambda = config.lambda ?? 0.5;
      this.random = seededRandom(config.seed ?? Date.now());
      this.nextWeatherEventEpoch = 0;
      this.initialize();
    }
    get tempo() {
      return this.config.tempo;
    }
    updateConfig(newConfig) {
      this.config = __spreadValues(__spreadValues({}, this.config), newConfig);
      if (newConfig.lambda)
        this.lambda = newConfig.lambda;
    }
    initialize() {
      this.random = seededRandom(this.config.seed ?? Date.now());
      this.nextWeatherEventEpoch = this.random.nextInt(12) + 8;
      this.branches = [];
      if (this.config.drumSettings.enabled) {
        const { events: drumAxiom } = createDrumAxiom(this.config.genre, this.config.mood, this.config.tempo, this.random);
        this.branches.push({ id: "drum_axon", events: drumAxiom, weight: 1, age: 0, technique: "hit", type: "drums", endTime: 0 });
      }
      this.createBassAxiom();
      this.needsBassReset = false;
      this.lastAccompanimentEndTime = -Infinity;
      this.nextAccompanimentDelay = this.random.next() * 7 + 5;
    }
    createBassAxiom() {
      this.bassPhraseLibrary = [];
      const numPhrases = 2 + this.random.nextInt(3);
      const anchorPhrase = generateAmbientBassPhrase(this.config.mood, this.config.genre, this.random);
      this.bassPhraseLibrary.push(anchorPhrase);
      for (let i = 1; i < numPhrases; i++) {
        this.bassPhraseLibrary.push(mutateBassPhrase(anchorPhrase, this.config.mood, this.config.genre, this.random));
      }
      this.bassPlayPlan = [];
      const planLength = 3 + this.random.nextInt(2);
      for (let i = 0; i < planLength; i++) {
        this.bassPlayPlan.push({
          phraseIndex: this.random.nextInt(numPhrases),
          repetitions: 1 + this.random.nextInt(3)
        });
      }
      this.currentPlanIndex = 0;
      this.currentRepetition = 0;
      this.barsInCurrentPhrase = 0;
      console.log(`[BassAxiom] Created new bass plan with ${numPhrases} related phrases. Plan length: ${planLength}`);
    }
    generateExternalImpulse() {
      console.log(`%c[WEATHER EVENT] at epoch ${this.epoch}: Triggering linked mutation.`, "color: blue; font-weight: bold;");
      const { drumFill, bassFill } = createRhythmSectionFill(this.config.mood, this.config.genre, this.random);
      this.drumFillForThisEpoch = drumFill;
      console.log(`%c  -> Created ONE-OFF DRUM fill for this epoch.`, "color: blue;");
      if (bassFill.length > 0) {
        const bassFillBranch = {
          id: `bass_response_${this.epoch}`,
          events: bassFill,
          weight: 1.5,
          age: 0,
          technique: "fill",
          type: "bass",
          endTime: bassFill.reduce((max, e) => Math.max(max, e.time + e.duration), 0)
        };
        this.branches.push(bassFillBranch);
        console.log(`%c  -> Created BASS response branch: ${bassFillBranch.id}`, "color: blue;");
      }
    }
    selectBranchForMutation(type) {
      const candidates = this.branches.filter((b) => b.type === type && b.age > 1);
      if (candidates.length === 0) {
        const allTypeBranches = this.branches.filter((b) => b.type === type);
        if (allTypeBranches.length === 0)
          return null;
        return allTypeBranches.reduce((oldest, b) => b.age > oldest.age ? b : oldest, allTypeBranches[0]);
      }
      const totalWeight = candidates.reduce((sum, b) => sum + b.weight, 0);
      if (totalWeight === 0)
        return candidates[0] || null;
      let random = this.random.next() * totalWeight;
      for (const branch of candidates) {
        random -= branch.weight;
        if (random <= 0)
          return branch;
      }
      return candidates[candidates.length - 1];
    }
    mutateBranch(parent) {
      const newEvents = JSON.parse(JSON.stringify(parent.events));
      let endTime = 0;
      if (parent.type === "bass") {
        const newFill = createBassFill.call(this, this.config.mood, this.config.genre, this.random);
        if (newFill.length === 0)
          return null;
        endTime = newFill.reduce((max, e) => Math.max(max, e.time + e.duration), 0);
        return {
          id: `bass_mut_${this.epoch}`,
          events: newFill,
          weight: parent.weight * 0.2,
          // Увеличен штраф
          age: 0,
          technique: "fill",
          type: "bass",
          endTime
        };
      } else if (parent.type === "drums") {
        const mutationType = this.random.nextInt(4);
        let mutationApplied = false;
        switch (mutationType) {
          case 0:
            newEvents.forEach((e) => {
              if (e.type === "drum_hihat_closed" && this.random.next() > 0.7) {
                e.type = "drum_ride";
                mutationApplied = true;
              }
            });
            break;
          case 1:
            const percPool = PERCUSSION_SETS.NEUTRAL;
            const timeSlots = [0.25, 0.75, 1.25, 1.75, 2.25, 2.75, 3.25, 3.75];
            const targetTime = timeSlots[this.random.nextInt(timeSlots.length)];
            if (!newEvents.some((e) => Math.abs(e.time - targetTime) < 0.1)) {
              newEvents.push(__spreadProps(__spreadValues({}, {
                type: percPool[this.random.nextInt(percPool.length)],
                note: 36,
                duration: 0.1,
                time: targetTime,
                weight: 0.6,
                technique: "hit",
                dynamics: "p",
                phrasing: "staccato"
              }), {
                params: getParamsForTechnique("hit", this.config.mood, this.config.genre)
              }));
              mutationApplied = true;
            }
            break;
          case 2:
            const snareIndex = newEvents.findIndex((e) => e.type === "drum_snare");
            if (snareIndex > -1 && this.random.next() > 0.5) {
              newEvents[snareIndex].time += this.random.next() > 0.5 ? 0.25 : -0.25;
              newEvents[snareIndex].time = (newEvents[snareIndex].time + 4) % 4;
              mutationApplied = true;
            } else {
              const snareToReplace = newEvents.find((e) => e.type === "drum_snare");
              if (snareToReplace) {
                snareToReplace.type = "drum_tom_mid";
                mutationApplied = true;
              }
            }
            break;
          case 3:
            const hihats = newEvents.filter((e) => e.type === "drum_hihat_closed");
            if (hihats.length > 0 && this.random.next() > 0.5) {
              const targetHat = hihats[this.random.nextInt(hihats.length)];
              newEvents.push(__spreadValues({}, targetHat, { time: targetHat.time + 0.25 }));
              mutationApplied = true;
            }
            break;
        }
        if (!mutationApplied)
          return null;
        endTime = newEvents.reduce((max, e) => Math.max(max, e.time + e.duration), 0);
        return { id: `drum_mut_${this.epoch}`, events: newEvents, weight: parent.weight * 0.8, age: 0, technique: "hit", type: "drums", endTime };
      } else if (parent.type === "accompaniment") {
        const bassBranches = this.branches.filter(isBass2);
        const currentBassNote = bassBranches.length > 0 ? bassBranches[0].events[0]?.note ?? 40 : 40;
        const newAxiom = createAccompanimentAxiom(this.config.mood, this.config.genre, this.random, currentBassNote);
        if (newAxiom.length === 0)
          return null;
        endTime = newAxiom.reduce((max, e) => Math.max(max, e.time + e.duration), 0);
        return {
          id: `accomp_mut_${this.epoch}`,
          events: newAxiom,
          weight: 1.2,
          // New accompaniment phrases start with strong weight to ensure they play
          age: 0,
          technique: "swell",
          type: "accompaniment",
          endTime
        };
      }
      return null;
    }
    applyNaturalDecay(events, barDuration) {
      const bassEvents = events.filter(isBass);
      if (bassEvents.length === 0)
        return events;
      const lastBassEvent = bassEvents.reduce((last, current) => current.time > last.time ? current : last);
      if (lastBassEvent.time + lastBassEvent.duration >= barDuration - 0.1) {
        if (!lastBassEvent.params) {
          lastBassEvent.params = { cutoff: 300, resonance: 0.8, distortion: 0.02, portamento: 0, attack: 0.2 };
        }
        lastBassEvent.params.release = Math.min(lastBassEvent.duration * 0.8, 1.5);
      }
      return events;
    }
    generateOneBar(barDuration) {
      var _a, _b;
      let instrumentHints = {};
      let shouldPlayAccompaniment = false;
      if (this.time >= this.lastAccompanimentEndTime + this.nextAccompanimentDelay) {
        shouldPlayAccompaniment = true;
      }
      if (this.config.composerControlsInstruments && shouldPlayAccompaniment) {
        const possibleInstruments = ["violin", "flute", "synth", "organ", "mellotron", "theremin", "E-Bells_melody", "G-Drops"];
        instrumentHints.accompaniment = possibleInstruments[this.random.nextInt(possibleInstruments.length)];
      }
      const output = [];
      const planItem = this.bassPlayPlan[this.currentPlanIndex];
      if (planItem && this.bassPhraseLibrary.length > 0) {
        const phrase = this.bassPhraseLibrary[planItem.phraseIndex];
        const phraseDurationInBeats = phrase.reduce((max, e) => Math.max(max, e.time + e.duration), 0);
        const phraseDurationInBars = Math.ceil(phraseDurationInBeats / 4);
        if (this.barsInCurrentPhrase === 0) {
          output.push(...phrase);
        }
        this.barsInCurrentPhrase++;
        if (this.barsInCurrentPhrase >= phraseDurationInBars) {
          this.currentRepetition++;
          this.barsInCurrentPhrase = 0;
          if (this.currentRepetition >= planItem.repetitions) {
            this.currentRepetition = 0;
            this.currentPlanIndex++;
            if (this.currentPlanIndex >= this.bassPlayPlan.length) {
              this.createBassAxiom();
              console.log(`%c[BASS PLAN] Loop finished. Regenerating phrase library and plan.`, "color: #FF7F50");
            }
          }
        }
      } else {
        this.createBassAxiom();
      }
      const drumBranches = this.branches.filter((b) => b.type === "drums");
      if (drumBranches.length > 0) {
        const winningDrumBranch = drumBranches.reduce((max, b) => b.weight > max.weight ? b : max, drumBranches[0]);
        let drumEvents = winningDrumBranch.events;
        if (this.drumFillForThisEpoch) {
          drumEvents = this.drumFillForThisEpoch;
          this.drumFillForThisEpoch = null;
        }
        output.push(...drumEvents.map((event) => __spreadValues({
          weight: 1
        }, event)));
      }
      const accompBranches = this.branches.filter((b) => b.type === "accompaniment");
      if (shouldPlayAccompaniment && accompBranches.length > 0) {
        const winningAccompBranch = accompBranches.reduce((max, b) => b.weight > max.weight ? b : max, accompBranches[0]);
        output.push(...winningAccompBranch.events);
        const beatDuration = 60 / this.config.tempo;
        this.lastAccompanimentEndTime = this.time + winningAccompBranch.endTime * beatDuration;
        this.nextAccompanimentDelay = this.random.next() * 7 + 5;
        console.log(`%c[ACCOMPANIMENT] at epoch ${this.epoch}: Playing phrase. Next in ~${this.nextAccompanimentDelay.toFixed(1)}s.`, "color: magenta;");
      }
      this.evolveBranches();
      const finalEvents = this.applyNaturalDecay(output, 4);
      return { events: finalEvents, instrumentHints };
    }
    evolveBranches() {
      var _a, _b;
      const shouldMutateBass = this.random.next() < this.config.density * 0.5;
      const shouldMutateDrums = this.random.next() < this.config.density * 0.5;
      const shouldMutateAccomp = this.random.next() < this.config.density * 0.3;
      if (this.epoch % 2 === 1 && this.branches.filter((b) => b.type === "bass").length < 5) {
        if (shouldMutateBass) {
          const parentBranch = this.selectBranchForMutation("bass");
          if (parentBranch) {
            const newBranch = this.mutateBranch(parentBranch);
            if (newBranch)
              this.branches.push(newBranch);
          }
        }
      }
      if (this.epoch % 4 === 1) {
        if (shouldMutateDrums && this.branches.filter((b) => b.type === "drums").length < 5) {
          const parentBranch = this.selectBranchForMutation("drums");
          if (parentBranch) {
            const newBranch = this.mutateBranch(parentBranch);
            if (newBranch) {
              this.branches.push(newBranch);
              console.log(`%c[MUTATION] at epoch ${this.epoch}: Created new drum branch ${newBranch.id}.`, "color: darkorange;");
            }
          }
        }
      }
      if (this.epoch % 5 === 1) {
        if (shouldMutateAccomp && this.branches.filter((b) => b.type === "accompaniment").length < 3) {
          const parentBranch = this.selectBranchForMutation("accompaniment");
          if (parentBranch) {
            const newBranch = this.mutateBranch(parentBranch);
            if (newBranch)
              this.branches.push(newBranch);
          } else {
            const bassBranches = this.branches.filter(isBass2);
            const currentBassNote = bassBranches.length > 0 ? ((_b = (_a = bassBranches[0].events) == null ? void 0 : _a[0]) == null ? void 0 : _b.note) ?? 40 : 40;
            const newAxiom = createAccompanimentAxiom(this.config.mood, this.config.genre, this.random, currentBassNote);
            if (newAxiom.length > 0) {
              const endTime = newAxiom.reduce((max, e) => Math.max(max, e.time + e.duration), 0);
              this.branches.push({ id: `accomp_axiom_${this.epoch}`, events: newAxiom, weight: 1, age: 0, technique: "swell", type: "accompaniment", endTime });
            }
          }
        }
      }
    }
    evolve(barDuration, barCount) {
      if (this.epoch >= this.nextWeatherEventEpoch) {
        this.generateExternalImpulse();
        this.nextWeatherEventEpoch += this.random.nextInt(12) + 8;
      }
      const delta = this.getDeltaProfile()(this.time);
      if (!isFinite(barDuration))
        return { events: [], instrumentHints: {} };
      this.branches.forEach((branch) => {
        const ageBonus = branch.age === 0 ? 1.5 : 1;
        const resonanceSum = this.branches.reduce((sum, other) => {
          if (!branch.events[0] || !other.events[0] || other.id === branch.id || other.type === branch.type)
            return sum;
          const k = MelancholicMinorK(branch.events[0], other.events[0], { mood: this.config.mood, tempo: this.config.tempo, delta, genre: this.config.genre });
          return sum + k * delta * other.weight;
        }, 0);
        let newWeight = ((1 - this.lambda) * branch.weight + resonanceSum) * ageBonus;
        if (branch.type === "bass" && branch.events.some((e) => e.note > 52)) {
          newWeight *= 0.2;
        }
        branch.weight = isFinite(newWeight) ? Math.max(0, newWeight) : 0.01;
        branch.age++;
      });
      const bassBranches = this.branches.filter((b) => b.type === "bass");
      if (bassBranches.length === 0 || bassBranches.every((b) => b.weight < 0.3)) {
        console.log(`%c[BASS REVIVAL] All bass branches are weak. Creating new axiom.`, "color: #4169E1;");
        this.createBassAxiom();
      }
      ["bass", "drums", "accompaniment"].forEach((type) => {
        const typeBranches = this.branches.filter((b) => b.type === type);
        const totalWeight = typeBranches.reduce((sum, b) => sum + b.weight, 0);
        if (totalWeight > 0) {
          typeBranches.forEach((b) => b.weight /= totalWeight);
        }
      });
      this.branches = this.branches.filter((b) => {
        if (b.type === "accompaniment")
          return b.age < 2;
        return b.weight > 0.05 || b.age < 8;
      });
      const { events, instrumentHints } = this.generateOneBar(barDuration);
      this.time += barDuration;
      return { events, instrumentHints };
    }
    getDeltaProfile() {
      return (t) => {
        const safeT = safeTime(t);
        const phase = safeT / 120 % 1;
        if (this.config.mood === "melancholic" || this.config.mood === "dreamy" || this.config.mood === "dark") {
          if (phase < 0.4)
            return 0.3 + phase * 1.5;
          if (phase < 0.7)
            return 1;
          return 1 - (phase - 0.7) * 2.3;
        } else {
          if (phase < 0.3)
            return 0.5 + phase * 1.6;
          if (phase < 0.6)
            return 1;
          return 1 - (phase - 0.6) * 1.6;
        }
      };
    }
  };

  // src/lib/ambient.worker.ts
  var lastSparkleTime = -Infinity;
  function shouldAddSparkle(currentTime, density, genre) {
    const timeSinceLast = currentTime - lastSparkleTime;
    const baseMinTime = 30;
    const baseMaxTime = 90;
    const isAmbient = genre === "ambient";
    const minTime = isAmbient ? 15 : baseMinTime;
    const maxTime = isAmbient ? 45 : baseMaxTime;
    if (timeSinceLast < minTime)
      return false;
    if (density > 0.6 && !isAmbient)
      return false;
    const chance = (timeSinceLast - minTime) / (maxTime - minTime) * (1 - density);
    return Math.random() < chance;
  }
  var fractalMusicEngine;
  var Scheduler = {
    loopId: null,
    isRunning: false,
    barCount: 0,
    settings: {
      bpm: 75,
      score: "neuro_f_matrix",
      genre: "ambient",
      drumSettings: { pattern: "composer", enabled: true, volume: 0.5, kickVolume: 1 },
      instrumentSettings: {
        bass: { name: "glideBass", volume: 0.7, technique: "portamento" },
        melody: { name: "acousticGuitarSolo", volume: 0.8 },
        accompaniment: { name: "guitarChords", volume: 0.7 }
      },
      textureSettings: {
        sparkles: { enabled: true }
      },
      density: 0.5,
      composerControlsInstruments: true,
      mood: "melancholic"
    },
    get barDuration() {
      return 60 / this.settings.bpm * 4;
    },
    initializeEngine(settings) {
      var _a;
      fractalMusicEngine = new FractalMusicEngine(__spreadValues({
        tempo: settings.bpm,
        density: settings.density,
        lambda: 1 - (settings.density * 0.5 + 0.3),
        organic: settings.density,
        drumSettings: settings.drumSettings,
        mood: settings.mood,
        genre: settings.genre,
        seed: (_a = settings.seed) != null ? _a : Date.now()
      }, settings));
      this.barCount = 0;
      lastSparkleTime = -Infinity;
    },
    start() {
      if (this.isRunning)
        return;
      this.isRunning = true;
      if (!fractalMusicEngine) {
        this.initializeEngine(this.settings);
      }
      const loop = () => {
        if (!this.isRunning)
          return;
        this.tick();
        this.loopId = setTimeout(loop, this.barDuration * 1e3);
      };
      loop();
    },
    stop() {
      this.isRunning = false;
      if (this.loopId) {
        clearTimeout(this.loopId);
        this.loopId = null;
      }
    },
    reset() {
      if (this.isRunning) {
        this.stop();
      }
      this.initializeEngine(this.settings);
      if (this.settings.bpm > 0) {
        this.start();
      }
    },
    updateSettings(newSettings) {
      const needsRestart = this.isRunning && newSettings.bpm !== void 0 && newSettings.bpm !== this.settings.bpm;
      const scoreChanged = newSettings.score && newSettings.score !== this.settings.score;
      const moodChanged = newSettings.mood && newSettings.mood !== this.settings.mood;
      const genreChanged = newSettings.genre && newSettings.genre !== this.settings.genre;
      const wasNotInitialized = !fractalMusicEngine;
      if (needsRestart)
        this.stop();
      this.settings = __spreadProps(__spreadValues(__spreadValues({}, this.settings), newSettings), {
        drumSettings: newSettings.drumSettings ? __spreadValues(__spreadValues({}, this.settings.drumSettings), newSettings.drumSettings) : this.settings.drumSettings,
        instrumentSettings: newSettings.instrumentSettings ? __spreadValues(__spreadValues({}, this.settings.instrumentSettings), newSettings.instrumentSettings) : this.settings.instrumentSettings,
        textureSettings: newSettings.textureSettings ? __spreadValues(__spreadValues({}, this.settings.textureSettings), newSettings.textureSettings) : this.settings.textureSettings
      });
      if (wasNotInitialized || scoreChanged || moodChanged || genreChanged) {
        this.initializeEngine(this.settings);
      } else if (fractalMusicEngine) {
        fractalMusicEngine.updateConfig({
          tempo: this.settings.bpm,
          density: this.settings.density,
          organic: this.settings.density,
          drumSettings: this.settings.drumSettings,
          lambda: 1 - (this.settings.density * 0.5 + 0.3),
          mood: this.settings.mood,
          genre: this.settings.genre
        });
      }
      if (needsRestart)
        this.start();
    },
    tick() {
      var _a, _b;
      if (!this.isRunning || !fractalMusicEngine)
        return;
      const density = this.settings.density;
      const genre = this.settings.genre;
      let scorePayload = { events: [], instrumentHints: {} };
      if (this.settings.score === "neuro_f_matrix") {
        scorePayload = fractalMusicEngine.evolve(this.barDuration, this.barCount);
      }
      console.log(`[Worker] Tick ${this.barCount}. Generated ${(_b = (_a = scorePayload.events) == null ? void 0 : _a.length) != null ? _b : "undefined"} events.`);
      self.postMessage({
        type: "SCORE_READY",
        payload: {
          events: scorePayload.events,
          instrumentHints: scorePayload.instrumentHints,
          barDuration: this.barDuration
        }
      });
      const currentTime = this.barCount * this.barDuration;
      if (this.barCount >= 4 && this.settings.textureSettings.sparkles.enabled) {
        if (shouldAddSparkle(currentTime, density, genre)) {
          const sparkleGenre = genre === "ambient" ? "trance" : genre;
          self.postMessage({ type: "sparkle", time: 0, genre: sparkleGenre, mood: this.settings.mood });
          lastSparkleTime = currentTime;
        }
      }
      this.barCount++;
    }
  };
  self.onmessage = async (event) => {
    if (!event.data || !event.data.command) {
      return;
    }
    const { command, data } = event.data;
    try {
      switch (command) {
        case "init":
          Scheduler.updateSettings(data);
          Scheduler.initializeEngine(data);
          break;
        case "start":
          Scheduler.start();
          break;
        case "stop":
          Scheduler.stop();
          break;
        case "reset":
          Scheduler.reset();
          break;
        case "update_settings":
          Scheduler.updateSettings(data);
          break;
        case "external_impulse":
          if (fractalMusicEngine) {
            fractalMusicEngine.generateExternalImpulse();
          }
          break;
      }
    } catch (e) {
      self.postMessage({ type: "error", error: e instanceof Error ? e.message : String(e) });
    }
  };
  var ambient_worker_default = self;
  return __toCommonJS(ambient_worker_exports);
})();
