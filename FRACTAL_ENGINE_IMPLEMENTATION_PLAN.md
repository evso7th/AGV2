# План Реализации Фрактального Движка (FractalMusicEngine)

Этот документ описывает пошаговый план по созданию и интеграции нового генеративного музыкального движка, основанного на концепции "Фрактальной нейросети".

---

## Фаза 1: Создание фундамента и типов данных

**Цель:** Создать "скелет" системы и определить все необходимые структуры данных в TypeScript.

### Шаг 1.1: Создать `src/types/fractal.ts`

- **Что проверяем:**
  - Файл `src/types/fractal.ts` существует.
  - В файле определены и экспортированы все ключевые типы: `EventID`, `EngineState`, `ResonanceMatrix`, `EngineConfig`, `Seed`.
- **Как проверяем:**
  - Обзор структуры файлов проекта.
  - Code review файла `src/types/fractal.ts`.
- **Ожидаемый результат:**
  - Файл на месте, код соответствует описанию, нет ошибок TypeScript.

---

## Фаза 2: Создание прототипа Движка

**Цель:** Создать класс движка с минимальной логикой ("заглушкой") для безопасной интеграции в существующую архитектуру.

### Шаг 2.1: Создать `src/lib/fractal-music-engine.ts`

- **Что проверяем:**
  - Файл `src/lib/fractal-music-engine.ts` существует.
  - В файле определен класс `FractalMusicEngine`.
  - Конструктор класса принимает `seed` и репозиторий матриц.
  - Метод `tick()` существует, но может быть пустым.
  - Метод `generateScore()` существует и возвращает пустой объект `{}`.
- **Как проверяем:**
  - Обзор структуры файлов проекта.
  - Code review файла `src/lib/fractal-music-engine.ts`.
- **Ожидаемый результат:**
  - Файл на месте, класс и его методы определены, нет ошибок TypeScript.

---

## Фаза 3: Интеграция "каркаса" в существующую систему

**Цель:** Безопасно "встроить" новый, пока еще нефункциональный движок в работающее приложение, не нарушая его текущую логику.

### Шаг 3.1: Модифицировать `src/types/music.ts`

- **Что проверяем:**
  - В типе `ScoreName` добавлено новое значение `'fractal'`.
- **Как проверяем:**
  - Code review файла `src/types/music.ts`.
- **Ожидаемый результат:**
  - `export type ScoreName = 'evolve' | ... | 'multeity' | 'fractal';`

### Шаг 3.2: Модифицировать `src/lib/ambient.worker.ts`

- **Что проверяем:**
  - Воркер импортирует `FractalMusicEngine`.
  - Внутри `Scheduler.tick()` появилась условная логика, которая вызывает `fractalMusicEngine.tick()` при `score === 'fractal'`.
  - Старая логика для других стилей осталась нетронутой.
- **Как проверяем:**
  - Code review файла `src/lib/ambient.worker.ts`.
- **Ожидаемый результат:**
  - Воркер корректно делегирует вызовы разным композиторам в зависимости от выбранного стиля.

### Шаг 3.3: Модифицировать UI (`aura-groove.tsx` и `aura-groove-v2.tsx`)

- **Что проверяем:**
  - В выпадающем списке стилей появился новый пункт "Fractal".
- **Как проверяем:**
  - Запустить приложение и открыть UI.
  - Выбрать стиль "Fractal".
- **Ожидаемый результат:**
  - Приложение не падает. Музыка останавливается (так как `generateScore` возвращает пустоту), но интерфейс остается рабочим. Это подтверждает, что интеграция прошла успешно.

---

## Фаза 4: Реализация Математического Ядра

**Цель:** Воплотить вашу концептуальную формулу в работающий код внутри `FractalMusicEngine`.

### Шаг 4.1: Реализовать метод `tick()`

- **Что проверяем:**
  - Корректность реализации уравнения `w_{t+1}(j) = (1-λ)w_t(j) + Σ K_ij δ_i`.
  - Правильность работы функции нормализации весов (сумма всех `w` всегда равна 1).
  - Наличие и вызов методов `generateImpulse()` и `normalizeState()`.
- **Как проверяем:**
  - Code review `fractal-music-engine.ts`.
  - Добавление `console.log` в метод `tick()` для отслеживания изменения весов `this.state` на каждой итерации.
- **Ожидаемый результат:**
  - При каждом вызове `tick()` в консоли воркера видно, как распределение весов плавно меняется. Некоторые веса растут, другие — затухают. Сумма весов всегда остается равной 1.

### Шаг 4.2: Реализовать метод `generateScore()`

- **Что проверяем:**
  - Метод корректно анализирует `this.state` (карту весов).
  - Он выбирает 1-3 "ветви" с наибольшим весом.
  - Он преобразует эти "ветви" в массив нот `Note[]`, понятный для `AudioEngine`.
- **Как проверяем:**
  - Code review.
  - Запустить приложение, выбрать стиль "Fractal".
- **Ожидаемый результат:**
  - После выбора стиля "Fractal" и нажатия "Play", мы должны услышать первую сгенерированную музыку. Она может быть простой, но она должна звучать и меняться со временем.

---

## Фаза 5: Создание Первой Матрицы Резонанса `K`

**Цель:** Дать движку "душу" — первый набор музыкальных правил, определяющих стиль.

### Шаг 5.1: Создать `src/lib/resonance-matrices.ts`

- **Что проверяем:**
  - Файл создан.
  - В нем экспортируется как минимум одна функция-матрица, например, `MelancholicMinorK`.
  - Функция принимает два `EventID` и возвращает число, основанное на музыкальной логике (например, принадлежность к минорной гамме).
- **Как проверяем:**
  - Code review файла.
  - Интеграция этой матрицы в `FractalMusicEngine` в `ambient.worker.ts`.
- **Ожидаемый результат:**
  - При запуске движка со стилем "Fractal" музыка становится более осмысленной и мелодичной, явно придерживаясь минорной тональности. Исчезает ощущение случайности, появляется характер.
