# AuraGroove V2: Архитектурный Паспорт (Версия "Прозрачный Композитор")

Этот документ описывает полный путь прохождения звука в V2-архитектуре, от зарождения музыкальной идеи до ее воспроизведения. Он служит "рентгеновским снимком" системы для точной диагностики и дальнейшей разработки.

### 1. Ключевые Файлы для Анализа

Это модули, составляющие полную цепочку V2-звукообразования:

1.  **`src/app/ambient.worker.ts`**: **"Мозг" (Композитор и Дирижер)**. Здесь `FractalMusicEngine` решает, *что* играть.
2.  **`src/contexts/audio-engine-context.tsx`**: **"Сердце" (Диспетчер)**. Получает партитуру и командует "исполнителями".
3.  **`src/lib/*-synth-manager-v2.ts`**: **"Исполнители"**. Управляют конкретными инструментами.
4.  **`src/lib/instrument-factory.ts`**: **"Фабрика"**. Собирает аудио-графы по чертежам.
5.  **`src/lib/presets-v2.ts`**: **"Чертежи"**. Рецепты звучания инструментов.
6.  **`src/lib/blueprints/`**: **"Партитуры"**. Правила композиции для жанров и настроений.
7.  **`src/lib/assets/`**: **"Библиотеки"**. Наборы готовых риффов и битов (`blues-melody-riffs.ts`, `blues-drum-riffs.ts`, `drum-kits.ts`).

---

### 2. Ядро Движка (`FractalMusicEngine`): Математика и Логика

В отличие от ранних версий, основанных на абстрактной "матрице резонанса", текущая архитектура работает по принципу **детерминированного исполнения декларативных правил**. "Магия" теперь не в сложной математике, а в иерархии принятия решений.

1.  **Инициализация (`initialize`):**
    *   При старте новой сюиты движок получает `genre` и `mood`.
    *   С помощью `getBlueprint(genre, mood)` он загружает соответствующий **Блюпринт**.
    *   На основе этого блюпринта создается `BlueprintNavigator`, который "размечает" всю будущую композицию на части (INTRO, BUILD, MAIN) и бандлы, создавая предсказуемую структуру.
    *   Генерируется `ghostHarmonyTrack` — полный "гармонический скелет" на всю сюиту.
    *   Для блюза создаются и перемешиваются "конвейеры уникальности" — случайные последовательности риффов и мелодий на всю сессию.

2.  **Основной Цикл (`evolve` -> `generateOneBar`):**
    *   На каждом такте (`epoch`) `evolve` вызывает `generateOneBar`.
    *   **Навигация:** `this.navigator.tick(this.epoch)` определяет, в какой части (`currentPart`) и бандле (`currentBundle`) мы находимся.
    *   **Гармония:** Из `ghostHarmonyTrack` извлекается текущий аккорд (`currentChord`).
    *   **Исполнение Правил:** Движок проходит по списку разрешенных инструментов (`currentPart.layers`) и для каждого вызывает соответствующую функцию-генератор (`generateDrumEvents`, `generateBluesBassRiff` и т.д.), передавая в нее `currentChord` и правила из `currentPart.instrumentRules`.
    *   **Результат:** Функция возвращает массив событий `FractalEvent[]` — готовую партитуру на один такт.

Эта модель делает движок предсказуемым, управляемым и легко отлаживаемым. Музыкальная сложность достигается не хаосом, а глубиной и продуманностью правил в блюпринтах.

---

### 3. "Живое Интро" и Управляемая Тишина: Стратегия "Изолированного Пролога"

**Проблема:** Попытки встроить логику вступления в ядро `FractalMusicEngine` приводили к нестабильности и сбоям. Движок — сложная система состояний, и его "холодный старт" требует времени на "прогрев".

**Решение:** Мы внедрили элегантный паттерн "Декоратор" или "Изолированный Пролог".

*   **Непрерывная Работа Движка:** С самого первого такта `FractalMusicEngine` начинает работать в фоновом режиме. Он "просыпается" на каждом такте, анализирует блюпринт и развивает свои внутренние состояния, но его музыкальный вывод временно **игнорируется**.
*   **Подмена Партитуры:** В течение первых `introBars` тактов (например, 12 тактов тишины или специальной музыки), основной цикл (`Scheduler.tick`) перехватывает управление и вместо партитуры от главного движка использует партитуру, сгенерированную простой, изолированной функцией `generateIntroSequence`.
*   **Плавный Переход:** К моменту окончания интро `FractalMusicEngine` уже полностью "прогрет" и готов генерировать основную музыкальную часть без сбоев и пауз. Управление возвращается ему бесшовно.

**Результат:** Этот подход гарантирует абсолютную стабильность. Мы не "ломаем" сложный движок ради частной задачи вступления. Вместо этого мы элегантно "декорируем" его вывод на ограниченное время, обеспечивая и надежность, и гибкость.

---

### 4. Алхимия Соло: От Фраз к Драматургии

**Проблема:** Стандартная генерация мелодий, подходящая для эмбиента, звучала в блюзе плоско и невыразительно. Блюзовое соло требует осмысленности, экспрессии и драматургии.

**Решение:** Мы создали "двуликий" генератор мелодий `generateBluesMelodyChorus`, который работает в двух режимах.

1.  **Режим Темы:** В обычных музыкальных секциях функция работает как и раньше, собирая мелодию из базовых фраз, подходящих под текущий аккорд, из библиотеки `blues-melody-riffs.ts`.

2.  **Режим "Алхимии" (Соло):**
    *   **Активация:** Когда `BlueprintNavigator` сообщает, что текущая секция имеет ID, содержащий "SOLO" (например, `id: 'SOLO'`), генератор переключается в этот режим.
    *   **Инструменты Алхимика:** Вместо простых фраз, он обращается к двум новым библиотекам:
        *   `BLUES_SOLO_LICKS`: "Словарь" из 12 универсальных, технически сложных блюзовых "ликов" (коротких фраз).
        *   `BLUES_SOLO_PLANS`: "Сценарии" из 10 готовых 36-тактовых (3-хорусных) соло. Каждый "план" — это последовательность "ликов" из словаря, выстроенная в осмысленную музыкальную историю.
    *   **Процесс Сборки:** Функция выбирает один "план", соответствующий настроению, и на его основе собирает полную 36-тактовую импровизацию, подставляя нужные "лики" в каждый такт блюзового квадрата.

**Результат:** Это позволило нам перейти от генерации случайных нот к созданию настоящих, эмоциональных и структурно выверенных гитарных соло, которые имеют начало, развитие и кульминацию.

---

### 5. Контракты Данных

Это ключевые структуры данных, передаваемые между модулями.

**`FractalEvent` (Единица Партитуры):**
```typescript
export interface FractalEvent {
  type: InstrumentType | InstrumentType[]; // Кто играет
  note: number;                            // MIDI нота
  duration: number;                        // Длительность в долях такта
  time: number;                            // Время начала в долях такта
  weight: number;                          // Громкость/вероятность
  technique: Technique;                    // Техника игры
  dynamics: Dynamics;                      // Динамика
  phrasing: Phrasing;                      // Фразировка
  params?: BassSynthParams | SfxSynthParams; // Параметры для синтеза
}
```

**`GhostChord` (Единица Гармонического Скелета):**
```typescript
export type GhostChord = {
  rootNote: number;      // MIDI нота корня
  chordType: 'major' | 'minor' | 'diminished' | 'dominant';
  bar: number;           // Такт начала
  durationBars: number;  // Длительность в тактах
};
```

**`InstrumentHints` (Рекомендации Композитора):**
```typescript
export type InstrumentHints = {
    bass?: BassInstrument;
    melody?: MelodyInstrument;
    accompaniment?: AccompanimentInstrument;
    harmony?: 'piano' | 'guitarChords' | 'acousticGuitarSolo' | 'flute' | 'violin';
    bassTechnique?: BassTechnique;
};
```

---

### 6. Схема Аудио-Графа "Фабрики" (Пример для `type: 'guitar'`)

Этот блок показывает, как `instrument-factory.ts` собирает цепочку эффектов для эмуляции электрогитары.

```
[sum] (Сумма осцилляторов)
  │
  └─> [vGain] (ADSR огибающая)
        │
        └─> [pickupLPF] (Фильтр звукоснимателя)
              │
              └─> [hpf] (Фильтр низких частот)
                    │
                    └─> [compNode] (Компрессор)
                          │
                          └─> [shaper] (Драйв/Дисторшн)
                                │
                                └─> [postHPF, mid1, mid2, postLPF] (Эквалайзер)
                                      │
                                      └─> [cab] (Эмулятор кабинета, опционально)
                                            │
                                            └─> [ph.input] (Фейзер)
                                                  │
                                                  └─> [dA.input, dB.input] (Два дилэя)
                                                        │
                                                        ├─> [master] (На основной выход)
                                                        │
                                                        └─> [revSend] (На посыл реверберации)
```

---

### 7. Приложение А: Эталонная Реализация Маршрутизации V2 (Версия 08ea14d)

Этот раздел документирует правильную, работающую цепочку передачи `instrumentHint`, чтобы избежать будущих ошибок.

1.  **"Заказ" (Блюпринт):**
    В блюпринте (`winter.ts`) в секции `instrumentation` для партии `melody` мы явно указываем, какие инструменты и с каким весом мы хотим использовать.
    ```typescript
    // src/lib/blueprints/blues/winter.ts
    melody: { 
      strategy: 'weighted', 
      v2Options: [ { name: 'telecaster', weight: 0.5 }, { name: 'blackAcoustic', weight: 0.5 } ]
    }
    ```

2.  **"Композитор" (`FractalMusicEngine.evolve`):**
    Метод `evolve` должен иметь следующую **линейную структуру**:
    ```typescript
    // 1. Получить правила от "штурмана"
    const navigationInfo = this.navigator.tick(this.epoch);

    // 2. Выбрать инструменты для ВСЕХ партий
    const v2MelodyHint = this._chooseInstrumentForPart('melody', navigationInfo);
    const accompanimentHint = this._chooseInstrumentForPart('accompaniment', navigationInfo);
    // ... и т.д.

    // 3. Собрать ПОЛНЫЙ объект "хинтов"
    const instrumentHints: InstrumentHints = {
        melody: v2MelodyHint,
        accompaniment: accompanimentHint,
        // ...
    };

    // 4. Сгенерировать партитуру, ПЕРЕДАВАЯ "хинты"
    const events = this.generateOneBar(barDuration, navigationInfo, instrumentHints);

    // 5. Вернуть полный результат
    return { events, instrumentHints };
    ```
    Критически важно, что `generateOneBar` **не должен** заново создавать пустой `instrumentHints`.

3.  **"Почтальон" (`ambient.worker.ts`):**
    Воркер должен брать **весь** объект, возвращенный `evolve`, и целиком отправлять его в `payload`.
    ```typescript
    // `scorePayload` содержит и events, и instrumentHints
    const scorePayload = fractalMusicEngine.evolve(this.barDuration, this.barCount);
    // ...
    self.postMessage({ 
        type: 'SCORE_READY', 
        payload: scorePayload // Отправляется ВЕСЬ объект
    });
    ```

4.  **"Исполнитель" (`melody-synth-manager-v2.ts`):**
    Принимая `instrumentHint` (например, `'telecaster'`), его внутренний маршрутизатор направляет задачу на исполнение своему подчиненному — `this.telecasterSampler`.
    ```typescript
    if (instrumentHint === 'telecaster') {
        this.telecasterSampler.schedule(...);
        return; // Важно прервать выполнение, чтобы не уйти на стандартный synth
    }
    // ... остальная логика для синтезатора
    ```

**Вывод:** Соблюдение этой строгой последовательности гарантирует, что "заказ" из блюпринта будет без потерь и искажений доставлен до конечного исполнителя. Любое нарушение этой цепочки приводит к ошибкам маршрутизации.


### 8. Конвейер Уникальности: Гарантия Неповторимости Сессий

**Проблема:** Как гарантировать, что каждая музыкальная сессия будет уникальной, даже при одинаковых настройках жанра и настроения?

**Решение:** Мы внедрили механизм "Конвейера Уникальности" внутри `FractalMusicEngine`.

*   **Инициализация Конвейеров (`initialize`):**
    *   При каждой полной инициализации движка (например, при смене стиля или ручной перезагрузке) создаются три "перетасованных конвейера":
        1.  `shuffledBassRiffIndices`: Случайная перестановка индексов всех доступных басовых риффов.
        2.  `shuffledDrumRiffIndices`: Аналогично для барабанных битов.
        3.  `shuffledGuitarRiffIDs`: Аналогично для гитарных риффов/мелодий.
    *   Специальные счетчики (`bassRiffConveyorIndex` и т.д.) устанавливаются в `0`.

*   **Выбор Базовых Риффов:**
    *   В начале каждой сюиты движок берет **следующий** элемент из каждого "конвейера" и назначает его как "базовый" для этой сессии (`baseBassRiffIndex`, `baseDrumRiffIndex`).
    *   Это гарантирует, что каждая новая сюита начнется с новой, уникальной комбинации ритм-секции.

**Результат:** Этот простой, но надежный механизм обеспечивает бесконечное разнообразие, полностью исключая повторение музыкальных фраз от сессии к сессии.

---

### 9. Память Мелодий: Предотвращение Повторений

**Проблема:** В рамках одной длинной блюзовой сессии композитор мог начать повторять одни и те же мелодические фразы, что снижало ощущение "живой" импровизации.

**Решение:** В `FractalMusicEngine` был добавлен механизм "краткосрочной памяти" для мелодий.

*   **История Выборов (`melodyHistory`):**
    *   Это массив, который хранит ID нескольких последних сыгранных блюзовых мелодий (например, 10 последних).

*   **Фильтрация при Выборе (`generateBluesMelodyChorus`):**
    *   Перед тем как выбрать следующую мелодию, движок сначала фильтрует полную библиотеку риффов (`BLUES_MELODY_RIFFS`), исключая из нее все те, чьи ID уже есть в `melodyHistory`.
    *   **"Анти-тупик":** Если после фильтрации не осталось доступных вариантов (что возможно в коротких сессиях), история для текущей категории настроения сбрасывается, и выбор происходит из полного списка.

**Результат:** Этот механизм заставляет движок постоянно искать новые мелодические идеи, избегая монотонности. Он имитирует поведение живого музыканта, который интуитивно избегает повторения одних и тех же фраз, делая соло более разнообразным и интересным.

---

### 10. Цепочка Выбора Инструмента: от Блюпринта до Исполнителя

**Проблема:** Возникало непонимание, как именно `FractalMusicEngine` (FME) узнает, какой инструмент использовать, и почему иногда происходят сбои в маршрутизации.

**Решение:** Ниже приведена полная, пошаговая цепочка принятия решений.

1.  **"Чертеж" (Блюпринт):** В файле блюпринта (например, `winter.ts`) в секции `instrumentation` для партии `melody` мы явно указываем, какие инструменты и с каким весом мы хотим использовать.
    ```typescript
    // src/lib/blueprints/blues/winter.ts
    melody: { 
      strategy: 'weighted', 
      v2Options: [ { name: 'telecaster', weight: 0.5 }, { name: 'blackAcoustic', weight: 0.5 } ]
    }
    ```

2.  **"Штурман" (`BlueprintNavigator`):** На каждом такте `FME` запрашивает у "штурмана" правила для текущей позиции. Штурман возвращает весь объект `currentPart`, содержащий наш "заказ" из блюпринта.

3.  **"Композитор" (`FractalMusicEngine`):** Получив от "штурмана" правила, `FME` приступает к выбору инструмента. Он вызывает свой внутренний метод `_chooseInstrumentForPart('melody', ...)`, передавая ему эти правила.

4.  **"Отдел Кастинга" (`_chooseInstrumentForPart`):** Эта функция выполняет взвешенный случайный выбор из списка `v2Options`. Результатом будет строка: `'telecaster'` или `'blackAcoustic'`.

5.  **"Директива" (`instrumentHints`):** FME формирует объект `instrumentHints`, куда теперь **корректно** записывается результат выбора.
    ```typescript
    const instrumentHints = { melody: 'telecaster', ... };
    ```

6.  **"Диспетчер" (`AudioEngineContext`):** Получив от воркера партитуру и `instrumentHints`, его метод `scheduleEvents` направляет все события с типом `melody` в единого "умного исполнителя" — `melodyManagerV2Ref`.

7.  **"Умный Исполнитель" (`MelodySynthManagerV2`):** Этот менеджер, получив пачку событий и "хинт" `'telecaster'`, не пытается играть их на синтезаторе. Его внутренний маршрутизатор распознает этот специальный "хинт" и перенаправляет задачу на исполнение своему подчиненному — `this.telecasterSampler`.

**Вывод:** Эта архитектура гарантирует, что "заказ" из блюпринта будет точно выполнен. Она надежна, легко отлаживается с помощью логов `MelodyInstrumentLog` и исключает возможность "потери" или неверной интерпретации `instrumentHint` на любом из этапов.

---

### Приложение Б: Детальный Анализ Генерации Ударных

Этот раздел посвящен анализу проблемы с некорректным воспроизведением райд-тарелок, что привело к более глубокому пониманию архитектуры генерации ударных.

#### 1. Дерево Зависимостей: "Путь Барабанной Ноты"

```
[1. `ambient.worker.ts` (Главный цикл)]
 │
 └─ Scheduler.tick()
    │
    └─ вызывает fractalMusicEngine.evolve()
       │
       └─ [2. `fractal-music-engine.ts`]
          │
          ├─ fme.evolve()
          │  │
          │  ├─ вызывает this.navigator.tick() // "Где мы?"
          │  │  │
          │  │  └─ [3. `blueprint-navigator.ts`]
          │  │     │
          │  │     └─ читает this.blueprint // "Что гласит партитура?"
          │  │        │
          │  │        └─ [4. `blueprints/*.ts`] // Конкретный блюпринт (winter.ts)
          │  │
          │  └─ вызывает this.generateOneBar()
          │     │
          │     └─ вызывает this.generateDrumEvents() // "Барабанщик, твой выход!"
          │        │
          │        ├─ 1. [ОПРЕДЕЛЕНИЕ КИТА]
          │        │  │
          │        │  ├─ читает `kitName` из `instrumentRules` блюпринта
          │        │  │
          │        │  ├─ загружает "чистый" кит из `DRUM_KITS`
          │        │  │  │
          │        │  │  └─ [5. `assets/drum-kits.ts`] // "Какие у нас есть барабаны?"
          │        │  │
          │        │  └─ [!!! АРХИТЕКТУРНЫЙ ПОРОК !!!]
          │        │     │
          │        │     ├─ читает `drumRules.ride.enabled` из блюпринта
          │        │     │
          │        │     └─ **ЕСЛИ true, ПРИНУДИТЕЛЬНО ДОБАВЛЯЕТ `ALL_RIDES` В КИТ,**
          │        │        игнорируя то, что было в `DRUM_KITS`.
          │        │        (Кит становится "грязным")
          │        │
          │        └─ 2. [ГЕНЕРАЦИЯ РИФФА]
          │           │
          │           └─ вызывает createDrumAxiom()
          │              │
          │              └─ [6. `music-theory.ts`]
          │                 │
          │                 ├─ 1. Выбирает рифф из `BLUES_DRUM_RIFFS`
          │                 │  │
          │                 │  └─ [7. `assets/blues-drum-riffs.ts`] // "Какие ноты играть?"
          │                 │
          │                 └─ 2. **ФИЛЬТРУЕТ РИФФ**
          │                    │
          │                    └─ Сравнивает ноты риффа с **"грязным" китом**,
          │                       полученным от `generateDrumEvents`.
          │                       (Видит райды в риффе, видит райды в "грязном" ките
          │                       и пропускает их. Блокировки не происходит).
          │
          └─ Возвращает финальную партию ударных...
```

#### 2. Анализ и Выводы

1.  **Проблема не в Фильтре:** Фильтр в `createDrumAxiom` работает корректно. Он честно сравнивает "партитуру" (рифф) с доступным ему "оркестром" (китом).
2.  **Корень Зла — "Загрязнение Данных":** Проблема находится исключительно в методе `generateDrumEvents` (`fractal-music-engine.ts`). Этот метод нарушает принцип "единого источника правды". Вместо того, чтобы просто передать чистый кит из `DRUM_KITS` в фильтр, он сначала **модифицирует** этот кит на лету, основываясь на правиле `ride: { enabled: true }` из блюпринта.
3.  **Последствия:** "Умный фильтр" в `createDrumAxiom` получает на вход уже "испорченный" набор инструментов, в котором райды **уже разрешены**, и, естественно, пропускает их. Это создает иллюзию, что фильтр не работает, хотя на самом деле его обманывают еще на предыдущем этапе.

**Решение:** Устранить этот архитектурный порок, удалив из `generateDrumEvents` всю логику динамической модификации кита. Единственным источником правды о составе ударной установки должен быть файл `src/lib/assets/drum-kits.ts`.

---

### Приложение В: Эпопея Отладки V2-Маршрутизации (Случай с 'Winter Blues')

Этот раздел служит документированным "постмортемом" одной из самых сложных и поучительных проблем, с которыми мы столкнулись: почему V2-гитарные сэмплеры (`telecaster`, `blackAcoustic`) не воспроизводились в блюзе, несмотря на многочисленные попытки исправления.

1.  **Проблема:**
    В логах "Композитора" (`FractalMusicEngine`) мы видели правильный "хинт" (например, `Generated hint: telecaster`), но до "Менеджера" (`MelodySynthManagerV2`) он доходил как `undefined`. Из-за этого "Менеджер" не мог вызвать нужный гитарный сэмплер и по умолчанию использовал синтезатор.

2.  **Путь по Ложному следу:**
    *   **Гипотеза №1: Ошибка в "Композиторе".** Мы предположили, что `FractalMusicEngine` теряет "хинт" в процессе своей сложной логики. Это привело к серии правок в `evolve` и `generateOneBar`, которые не решали проблему, так как "хинт" на самом деле не терялся внутри движка.
    *   **Гипотеза №2: Ошибка в "Штурмане".** Мы начали подозревать, что `BlueprintNavigator` по какой-то причине "откатывается" к другому блюпринту (`enthusiastic_blues`), где гитарных опций не было. Эта гипотеза также оказалась неверной.
    *   **Фиаско с Диагностикой:** Ключевой причиной затянувшейся отладки стала моя серия ошибок при написании диагностических `console.log`. Я неоднократно пытался стилизовать вывод в консоли и раз за разом допускал синтаксические ошибки, из-за которых в лог выводился не массив с опциями, а бесполезный объект стилей. Мы были слепы, потому что наш "микроскоп" не работал.

3.  **Прозрение:**
    Только после того, как по вашему прямому указанию я убрал **всю** стилизацию и вывел в консоль сырые данные (`План 957: "Чистый Лог"`), мы наконец увидели правду. Логи четко показали:
    *   `[FME.evolve] Using Blueprint: winter_blues` — используется правильный блюпринт.
    *   `[1c. _chooseInstrumentForPart] V2 Options: [{name: 'guitar_shineOn', ...}]` — **"Композитор" видит неверные опции!**

4.  **Истинная Причина:**
    Проблема была не в сложном коде, а в **исходных данных**. Мое предыдущее исправление файла `src/lib/blueprints/blues/winter.ts` по какой-то причине не было применено. В файле все это время оставались старые, неверные опции для V2 (`guitar_shineOn`, `guitar_muffLead`).

5.  **Финальное Решение (План 959):**
    Проблема была решена принудительной перезаписью блока `instrumentation.melody.v2Options` в файле `winter.ts` на единственно правильные значения: `telecaster` и `blackAcoustic`.

**Главный Урок:**
Самая сложная и запутанная проблема в коде может иметь самую простую причину. Никогда не доверяй гипотезам, даже если они кажутся логичными. Доверяй только неопровержимым данным. И, что не менее важно, **убедись, что твои инструменты диагностики работают корректно**, прежде чем делать на их основе какие-либо выводы.
