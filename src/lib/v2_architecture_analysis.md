# AuraGroove V2: Архитектурный Паспорт (Версия "Прозрачный Композитор")

Этот документ описывает полный путь прохождения звука в V2-архитектуре, от зарождения музыкальной идеи до ее воспроизведения. Он служит "рентгеновским снимком" системы для точной диагностики и дальнейшей разработки.

### 1. Ключевые Файлы для Анализа

Это модули, составляющие полную цепочку V2-звукообразования:

1.  **`src/app/ambient.worker.ts`**: **"Мозг" (Композитор и Дирижер)**. Здесь `FractalMusicEngine` решает, *что* играть.
2.  **`src/contexts/audio-engine-context.tsx`**: **"Сердце" (Диспетчер)**. Получает партитуру и командует "исполнителями".
3.  **`src/lib/*-synth-manager-v2.ts`**: **"Исполнители"**. Управляют конкретными инструментами.
4.  **`src/lib/instrument-factory.ts`**: **"Фабрика"**. Собирает аудио-графы по чертежам.
5.  **`src/lib/presets-v2.ts`**: **"Чертежи"**. Рецепты звучания инструментов.
6.  **`src/lib/blueprints/`**: **"Партитуры"**. Правила композиции для жанров и настроений.
7.  **`src/lib/assets/`**: **"Библиотеки"**. Наборы готовых риффов и битов (`blues-melody-riffs.ts`, `blues-drum-riffs.ts`, `drum-kits.ts`).

---

### 2. Ядро Движка (`FractalMusicEngine`): Математика и Логика

В отличие от ранних версий, основанных на абстрактной "матрице резонанса", текущая архитектура работает по принципу **детерминированного исполнения декларативных правил**. "Магия" теперь не в сложной математике, а в иерархии принятия решений.

1.  **Инициализация (`initialize`):**
    *   При старте новой сюиты движок получает `genre` и `mood`.
    *   С помощью `getBlueprint(genre, mood)` он загружает соответствующий **Блюпринт**.
    *   На основе этого блюпринта создается `BlueprintNavigator`, который "размечает" всю будущую композицию на части (INTRO, BUILD, MAIN) и бандлы, создавая предсказуемую структуру.
    *   Генерируется `ghostHarmonyTrack` — полный "гармонический скелет" на всю сюиту.
    *   Для блюза создаются и перемешиваются "конвейеры уникальности" — случайные последовательности риффов и мелодий на всю сессию.

2.  **Основной Цикл (`evolve` -> `generateOneBar`):**
    *   На каждом такте (`epoch`) `evolve` вызывает `generateOneBar`.
    *   **Навигация:** `this.navigator.tick(this.epoch)` определяет, в какой части (`currentPart`) и бандле (`currentBundle`) мы находимся.
    *   **Гармония:** Из `ghostHarmonyTrack` извлекается текущий аккорд (`currentChord`).
    *   **Исполнение Правил:** Движок проходит по списку разрешенных инструментов (`currentPart.layers`) и для каждого вызывает соответствующую функцию-генератор (`generateDrumEvents`, `generateBluesBassRiff` и т.д.), передавая в нее `currentChord` и правила из `currentPart.instrumentRules`.
    *   **Результат:** Функция возвращает массив событий `FractalEvent[]` — готовую партитуру на один такт.

Эта модель делает движок предсказуемым, управляемым и легко отлаживаемым. Музыкальная сложность достигается не хаосом, а глубиной и продуманностью правил в блюпринтах.

---

### 3. "Живое Интро" и Управляемая Тишина: Стратегия "Изолированного Пролога"

**Проблема:** Попытки встроить логику вступления в ядро `FractalMusicEngine` приводили к нестабильности и сбоям. Движок — сложная система состояний, и его "холодный старт" требует времени на "прогрев".

**Решение:** Мы внедрили элегантный паттерн "Декоратор" или "Изолированный Пролог".

*   **Непрерывная Работа Движка:** С самого первого такта `FractalMusicEngine` начинает работать в фоновом режиме. Он "просыпается" на каждом такте, анализирует блюпринт и развивает свои внутренние состояния, но его музыкальный вывод временно **игнорируется**.
*   **Подмена Партитуры:** В течение первых `introBars` тактов (например, 12 тактов тишины или специальной музыки), основной цикл (`Scheduler.tick`) перехватывает управление и вместо партитуры от главного движка использует партитуру, сгенерированную простой, изолированной функцией `generateIntroSequence`.
*   **Плавный Переход:** К моменту окончания интро `FractalMusicEngine` уже полностью "прогрет" и готов генерировать основную музыкальную часть без сбоев и пауз. Управление возвращается ему бесшовно.

**Результат:** Этот подход гарантирует абсолютную стабильность. Мы не "ломаем" сложный движок ради частной задачи вступления. Вместо этого мы элегантно "декорируем" его вывод на ограниченное время, обеспечивая и надежность, и гибкость.

---

### 4. Алхимия Соло: От Фраз к Драматургии

**Проблема:** Стандартная генерация мелодий, подходящая для эмбиента, звучала в блюзе плоско и невыразительно. Блюзовое соло требует осмысленности, экспрессии и драматургии.

**Решение:** Мы создали "двуликий" генератор мелодий `generateBluesMelodyChorus`, который работает в двух режимах.

1.  **Режим Темы:** В обычных музыкальных секциях функция работает как и раньше, собирая мелодию из базовых фраз, подходящих под текущий аккорд, из библиотеки `blues-melody-riffs.ts`.

2.  **Режим "Алхимии" (Соло):**
    *   **Активация:** Когда `BlueprintNavigator` сообщает, что текущая секция имеет ID, содержащий "SOLO" (например, `id: 'SOLO'`), генератор переключается в этот режим.
    *   **Инструменты Алхимика:** Вместо простых фраз, он обращается к двум новым библиотекам:
        *   `BLUES_SOLO_LICKS`: "Словарь" из 12 универсальных, технически сложных блюзовых "ликов" (коротких фраз).
        *   `BLUES_SOLO_PLANS`: "Сценарии" из 10 готовых 36-тактовых (3-хорусных) соло. Каждый "план" — это последовательность "ликов" из словаря, выстроенная в осмысленную музыкальную историю.
    *   **Процесс Сборки:** Функция выбирает один "план", соответствующий настроению, и на его основе собирает полную 36-тактовую импровизацию, подставляя нужные "лики" в каждый такт блюзового квадрата.

**Результат:** Это позволило нам перейти от генерации случайных нот к созданию настоящих, эмоциональных и структурно выверенных гитарных соло, которые имеют начало, развитие и кульминацию.

---

### 5. Контракты Данных

Это ключевые структуры данных, передаваемые между модулями.

**`FractalEvent` (Единица Партитуры):**
```typescript
export interface FractalEvent {
  type: InstrumentType | InstrumentType[]; // Кто играет
  note: number;                            // MIDI нота
  duration: number;                        // Длительность в долях такта
  time: number;                            // Время начала в долях такта
  weight: number;                          // Громкость/вероятность
  technique: Technique;                    // Техника игры
  dynamics: Dynamics;                      // Динамика
  phrasing: Phrasing;                      // Фразировка
  params?: BassSynthParams | SfxSynthParams; // Параметры для синтеза
}
```

**`GhostChord` (Единица Гармонического Скелета):**
```typescript
export type GhostChord = {
  rootNote: number;      // MIDI нота корня
  chordType: 'major' | 'minor' | 'diminished' | 'dominant';
  bar: number;           // Такт начала
  durationBars: number;  // Длительность в тактах
};
```

**`InstrumentHints` (Рекомендации Композитора):**
```typescript
export type InstrumentHints = {
    bass?: BassInstrument;
    melody?: MelodyInstrument;
    accompaniment?: AccompanimentInstrument;
    harmony?: 'piano' | 'guitarChords' | 'acousticGuitarSolo' | 'flute' | 'violin';
    bassTechnique?: BassTechnique;
};
```

---

### 6. Схема Аудио-Графа "Фабрики" (Пример для `type: 'guitar'`)

Этот блок показывает, как `instrument-factory.ts` собирает цепочку эффектов для эмуляции электрогитары.

```
[sum] (Сумма осцилляторов)
  │
  └─> [vGain] (ADSR огибающая)
        │
        └─> [pickupLPF] (Фильтр звукоснимателя)
              │
              └─> [hpf] (Фильтр низких частот)
                    │
                    └─> [compNode] (Компрессор)
                          │
                          └─> [shaper] (Драйв/Дисторшн)
                                │
                                └─> [postHPF, mid1, mid2, postLPF] (Эквалайзер)
                                      │
                                      └─> [cab] (Эмулятор кабинета, опционально)
                                            │
                                            └─> [ph.input] (Фейзер)
                                                  │
                                                  └─> [dA.input, dB.input] (Два дилэя)
                                                        │
                                                        ├─> [master] (На основной выход)
                                                        │
                                                        └─> [revSend] (На посыл реверберации)
```

---

### 7. Приложение А: Эталонная Реализация Маршрутизации V2 (Версия 08ea14d)

Этот раздел документирует правильную, работающую цепочку передачи `instrumentHint`, чтобы избежать будущих ошибок.

1.  **"Заказ" (Блюпринт):**
    В блюпринте (`winter.ts`) явно указывается желаемый инструмент для V2-движка.
    ```typescript
    instrumentation: {
      melody: { 
        strategy: 'weighted', 
        v2Options: [ { name: 'telecaster', weight: 0.5 }, { name: 'blackAcoustic', weight: 0.5 } ]
      }
    }
    ```

2.  **"Композитор" (`FractalMusicEngine.evolve`):**
    Метод `evolve` должен иметь следующую **линейную структуру**:
    ```typescript
    // 1. Получить правила от "штурмана"
    const navigationInfo = this.navigator.tick(this.epoch);

    // 2. Выбрать инструменты для ВСЕХ партий
    const v2MelodyHint = this._chooseInstrumentForPart('melody', navigationInfo);
    const accompanimentHint = this._chooseInstrumentForPart('accompaniment', navigationInfo);
    // ... и т.д.

    // 3. Собрать ПОЛНЫЙ объект "хинтов"
    const instrumentHints: InstrumentHints = {
        melody: v2MelodyHint,
        accompaniment: accompanimentHint,
        // ...
    };

    // 4. Сгенерировать партитуру, ПЕРЕДАВАЯ "хинты"
    const events = this.generateOneBar(barDuration, navigationInfo, instrumentHints);

    // 5. Вернуть полный результат
    return { events, instrumentHints };
    ```
    Критически важно, что `generateOneBar` **не должен** заново создавать пустой `instrumentHints`.

3.  **"Почтальон" (`ambient.worker.ts`):**
    Воркер должен брать **весь** объект, возвращенный `evolve`, и целиком отправлять его в `payload`.
    ```typescript
    // `scorePayload` содержит и events, и instrumentHints
    const scorePayload = fractalMusicEngine.evolve(this.barDuration, this.barCount);
    // ...
    self.postMessage({ 
        type: 'SCORE_READY', 
        payload: scorePayload // Отправляется ВЕСЬ объект
    });
    ```

4.  **"Исполнитель" (`melody-synth-manager-v2.ts`):**
    Принимая `instrumentHint` (например, `'telecaster'`), его внутренний маршрутизатор направляет задачу на нужный сэмплер.
    ```typescript
    if (instrumentHint === 'telecaster') {
        this.telecasterSampler.schedule(...);
        return; // Важно прервать выполнение, чтобы не уйти на стандартный synth
    }
    // ... остальная логика для синтезатора
    ```

**Вывод:** Соблюдение этой строгой последовательности гарантирует, что "заказ" из блюпринта будет без потерь и искажений доставлен до конечного исполнителя. Любое нарушение этой цепочки приводит к ошибкам маршрутизации.


### 8. Конвейер Уникальности: Гарантия Неповторимости Сессий

**Проблема:** Как гарантировать, что каждая музыкальная сессия будет уникальной, даже при одинаковых настройках жанра и настроения?

**Решение:** Мы внедрили механизм "Конвейера Уникальности" внутри `FractalMusicEngine`.

*   **Инициализация Конвейеров (`initialize`):**
    *   При каждой полной инициализации движка (например, при смене стиля или ручной перезагрузке) создаются три "перетасованных конвейера":
        1.  `shuffledBassRiffIndices`: Случайная перестановка индексов всех доступных басовых риффов.
        2.  `shuffledDrumRiffIndices`: Аналогично для барабанных битов.
        3.  `shuffledGuitarRiffIDs`: Аналогично для гитарных риффов/мелодий.
    *   Специальные счетчики (`bassRiffConveyorIndex` и т.д.) устанавливаются в `0`.

*   **Выбор Базовых Риффов:**
    *   В начале каждой сюиты движок берет **следующий** элемент из каждого "конвейера" и назначает его как "базовый" для этой сессии (`baseBassRiffIndex`, `baseDrumRiffIndex`).
    *   Это гарантирует, что каждая новая сюита начнется с новой, уникальной комбинации ритм-секции.

**Результат:** Этот простой, но надежный механизм обеспечивает бесконечное разнообразие, полностью исключая повторение музыкальных фраз от сессии к сессии.

---

### 9. Память Мелодий: Предотвращение Повторений

**Проблема:** В рамках одной длинной блюзовой сессии композитор мог начать повторять одни и те же мелодические фразы, что снижало ощущение "живой" импровизации.

**Решение:** В `FractalMusicEngine` был добавлен механизм "краткосрочной памяти" для мелодий.

*   **История Выборов (`melodyHistory`):**
    *   Это массив, который хранит ID нескольких последних сыгранных блюзовых мелодий (например, 10 последних).

*   **Фильтрация при Выборе (`generateBluesMelodyChorus`):**
    *   Перед тем как выбрать следующую мелодию, движок сначала фильтрует полную библиотеку риффов (`BLUES_MELODY_RIFFS`), исключая из нее все те, чьи ID уже есть в `melodyHistory`.
    *   **"Анти-тупик":** Если после фильтрации не осталось доступных вариантов (что возможно в коротких сессиях), история для текущей категории настроения сбрасывается, и выбор происходит из полного списка.

**Результат:** Этот механизм заставляет движок постоянно искать новые мелодические идеи, избегая монотонности. Он имитирует поведение живого музыканта, который интуитивно избегает повторения одних и тех же фраз, делая соло более разнообразным и интересным.

---

### 10. Цепочка Выбора Инструмента: от Блюпринта до Исполнителя

**Проблема:** Возникало непонимание, как именно `FractalMusicEngine` (FME) узнает, какой инструмент использовать, и почему иногда происходят сбои в маршрутизации.

**Решение:** Ниже приведена полная, пошаговая цепочка принятия решений.

1.  **"Чертеж" (Блюпринт):** В файле блюпринта (например, `winter.ts`) в секции `instrumentation` для партии `melody` мы явно указываем, какие инструменты и с каким весом мы хотим использовать.
    ```typescript
    // src/lib/blueprints/blues/winter.ts
    melody: { 
      strategy: 'weighted', 
      v2Options: [ { name: 'telecaster', weight: 0.5 }, { name: 'blackAcoustic', weight: 0.5 } ]
    }
    ```

2.  **"Штурман" (`BlueprintNavigator`):** На каждом такте `FME` запрашивает у "штурмана" правила для текущей позиции. Штурман возвращает весь объект `currentPart`, содержащий наш "заказ" из блюпринта.

3.  **"Композитор" (`FractalMusicEngine`):** Получив от "штурмана" правила, `FME` приступает к выбору инструмента. Он вызывает свой внутренний метод `_chooseInstrumentForPart('melody', ...)`, передавая ему эти правила.

4.  **"Отдел Кастинга" (`_chooseInstrumentForPart`):** Эта функция выполняет взвешенный случайный выбор из списка `v2Options`. Результатом будет строка: `'telecaster'` или `'blackAcoustic'`.

5.  **"Директива" (`instrumentHints`):** FME формирует объект `instrumentHints`, куда теперь **корректно** записывается результат выбора.
    ```typescript
    const instrumentHints = { melody: 'telecaster', ... };
    ```

6.  **"Диспетчер" (`AudioEngineContext`):** Получив от воркера партитуру и `instrumentHints`, его метод `scheduleEvents` направляет все события с типом `melody` в единого "умного исполнителя" — `melodyManagerV2Ref`.

7.  **"Умный Исполнитель" (`MelodySynthManagerV2`):** Этот менеджер, получив пачку событий и "хинт" `'telecaster'`, не пытается играть их на синтезаторе. Его внутренний маршрутизатор распознает этот специальный "хинт" и перенаправляет задачу на исполнение своему подчиненному — `this.telecasterSampler`.

**Вывод:** Эта архитектура гарантирует, что "заказ" из блюпринта будет точно выполнен. Она надежна, легко отлаживается с помощью логов `MelodyInstrumentLog` и исключает возможность "потери" или неверной интерпретации `instrumentHint` на любом из этапов.

    