
# AuraGroove V2: Архитектурный Паспорт (Версия "Прозрачный Композитор")

Этот документ описывает полный путь прохождения звука в V2-архитектуре, от зарождения музыкальной идеи до ее воспроизведения. Он служит "рентгеновским снимком" системы для точной диагностики и дальнейшей разработки.

### 1. Ключевые Файлы для Анализа

Это модули, составляющие полную цепочку V2-звукообразования:

1.  **`src/app/ambient.worker.ts`**: **"Мозг" (Композитор и Дирижер)**. Здесь `FractalMusicEngine` решает, *что* играть.
2.  **`src/contexts/audio-engine-context.tsx`**: **"Сердце" (Диспетчер)**. Получает партитуру и командует "исполнителями".
3.  **`src/lib/*-synth-manager-v2.ts`**: **"Исполнители"**. Управляют конкретными инструментами.
4.  **`src/lib/instrument-factory.ts`**: **"Фабрика"**. Собирает аудио-графы по чертежам.
5.  **`src/lib/presets-v2.ts`**: **"Чертежи"**. Рецепты звучания инструментов.
6.  **`src/lib/blueprints/`**: **"Партитуры"**. Правила композиции для жанров и настроений.
7.  **`src/lib/assets/`**: **"Библиотеки"**. Наборы готовых риффов и битов (`blues-melody-riffs.ts`, `blues-drum-riffs.ts`, `drum-kits.ts`).

---

### 2. Ядро Движка (`FractalMusicEngine`): Математика и Логика

В отличие от ранних версий, основанных на абстрактной "матрице резонанса", текущая архитектура работает по принципу **детерминированного исполнения декларативных правил**. "Магия" теперь не в сложной математике, а в иерархии принятия решений.

1.  **Инициализация (`initialize`):**
    *   При старте новой сюиты движок получает `genre` и `mood`.
    *   С помощью `getBlueprint(genre, mood)` он загружает соответствующий **Блюпринт**.
    *   На основе этого блюпринта создается `BlueprintNavigator`, который "размечает" всю будущую композицию на части (INTRO, BUILD, MAIN) и бандлы, создавая предсказуемую структуру.
    *   Генерируется `ghostHarmonyTrack` — полный "гармонический скелет" на всю сюиту.
    *   Для блюза создаются и перемешиваются "конвейеры уникальности" — случайные последовательности риффов и мелодий на всю сессию.

2.  **Основной Цикл (`evolve` -> `generateOneBar`):**
    *   На каждом такте (`epoch`) `evolve` вызывает `generateOneBar`.
    *   **Навигация:** `this.navigator.tick(this.epoch)` определяет, в какой части (`currentPart`) и бандле (`currentBundle`) мы находимся.
    *   **Гармония:** Из `ghostHarmonyTrack` извлекается текущий аккорд (`currentChord`).
    *   **Исполнение Правил:** Движок проходит по списку разрешенных инструментов (`currentPart.layers`) и для каждого вызывает соответствующую функцию-генератор (`generateDrumEvents`, `generateBluesBassRiff` и т.д.), передавая в нее `currentChord` и правила из `currentPart.instrumentRules`.
    *   **Результат:** Функция возвращает массив событий `FractalEvent[]` — готовую партитуру на один такт.

Эта модель делает движок предсказуемым, управляемым и легко отлаживаемым. Музыкальная сложность достигается не хаосом, а глубиной и продуманностью правил в блюпринтах.

---

### 3. "Живое Интро" и Управляемая Тишина: Стратегия "Изолированного Пролога"

**Проблема:** Попытки встроить логику вступления в ядро `FractalMusicEngine` приводили к нестабильности и сбоям. Движок — сложная система состояний, и его "холодный старт" требует времени на "прогрев".

**Решение:** Мы внедрили элегантный паттерн "Декоратор" или "Изолированный Пролог".

*   **Непрерывная Работа Движка:** С самого первого такта `FractalMusicEngine` начинает работать в фоновом режиме. Он "просыпается" на каждом такте, анализирует блюпринт и развивает свои внутренние состояния, но его музыкальный вывод временно **игнорируется**.
*   **Подмена Партитуры:** В течение первых `introBars` тактов (например, 12 тактов тишины или специальной музыки), основной цикл (`Scheduler.tick`) перехватывает управление и вместо партитуры от главного движка использует партитуру, сгенерированную простой, изолированной функцией `generateIntroSequence`.
*   **Плавный Переход:** К моменту окончания интро `FractalMusicEngine` уже полностью "прогрет" и готов генерировать основную музыкальную часть без сбоев и пауз. Управление возвращается ему бесшовно.

**Результат:** Этот подход гарантирует абсолютную стабильность. Мы не "ломаем" сложный движок ради частной задачи вступления. Вместо этого мы элегантно "декорируем" его вывод на ограниченное время, обеспечивая и надежность, и гибкость.

---

### 4. Алхимия Соло: От Фраз к Драматургии

**Проблема:** Стандартная генерация мелодий, подходящая для эмбиента, звучала в блюзе плоско и невыразительно. Блюзовое соло требует осмысленности, экспрессии и драматургии.

**Решение:** Мы создали "двуликий" генератор мелодий `generateBluesMelodyChorus`, который работает в двух режимах.

1.  **Режим Темы:** В обычных музыкальных секциях функция работает как и раньше, собирая мелодию из базовых фраз, подходящих под текущий аккорд, из библиотеки `blues-melody-riffs.ts`.

2.  **Режим "Алхимии" (Соло):**
    *   **Активация:** Когда `BlueprintNavigator` сообщает, что текущая секция имеет ID, содержащий "SOLO" (например, `id: 'SOLO'`), генератор переключается в этот режим.
    *   **Инструменты Алхимика:** Вместо простых фраз, он обращается к двум новым библиотекам:
        *   `BLUES_SOLO_LICKS`: "Словарь" из 12 универсальных, технически сложных блюзовых "ликов" (коротких фраз).
        *   `BLUES_SOLO_PLANS`: "Сценарии" из 10 готовых 36-тактовых (3-хорусных) соло. Каждый "план" — это последовательность "ликов" из словаря, выстроенная в осмысленную музыкальную историю.
    *   **Процесс Сборки:** Функция выбирает один "план", соответствующий настроению, и на его основе собирает полную 36-тактовую импровизацию, подставляя нужные "лики" в каждый такт блюзового квадрата.

**Результат:** Это позволило нам перейти от генерации случайных нот к созданию настоящих, эмоциональных и структурно выверенных гитарных соло, которые имеют начало, развитие и кульминацию.

---

### 5. Контракты Данных

Это ключевые структуры данных, передаваемые между модулями.

**`FractalEvent` (Единица Партитуры):**
```typescript
export interface FractalEvent {
  type: InstrumentType | InstrumentType[]; // Кто играет
  note: number;                            // MIDI нота
  duration: number;                        // Длительность в долях такта
  time: number;                            // Время начала в долях такта
  weight: number;                          // Громкость/вероятность
  technique: Technique;                    // Техника игры
  dynamics: Dynamics;                      // Динамика
  phrasing: Phrasing;                      // Фразировка
  params?: BassSynthParams | SfxSynthParams; // Параметры для синтеза
  chordName?: string; // Для сэмплеров аккордов
}
```

**`GhostChord` (Единица Гармонического Скелета):**
```typescript
export type GhostChord = {
  rootNote: number;      // MIDI нота корня
  chordType: 'major' | 'minor' | 'diminished' | 'dominant';
  bar: number;           // Такт начала
  durationBars: number;  // Длительность в тактах
};
```

**`InstrumentHints` (Рекомендации Композитора):**
```typescript
export type InstrumentHints = {
    bass?: BassInstrument;
    melody?: MelodyInstrument;
    accompaniment?: AccompanimentInstrument;
    harmony?: 'piano' | 'guitarChords' | 'violin' | 'flute' | 'none';
    bassTechnique?: BassTechnique;
};
```

---

### 6. Схема Аудио-Графа "Фабрики" (Пример для `type: 'guitar'`)

Этот блок показывает, как `instrument-factory.ts` собирает цепочку эффектов для эмуляции электрогитары.

```
[sum] (Сумма осцилляторов)
  │
  └─> [vGain] (ADSR огибающая)
        │
        └─> [pickupLPF] (Фильтр звукоснимателя)
              │
              └─> [hpf] (Фильтр низких частот)
                    │
                    └─> [compNode] (Компрессор)
                          │
                          └─> [shaper] (Драйв/Дисторшн)
                                │
                                └─> [postHPF, mid1, mid2, postLPF] (Эквалайзер)
                                      │
                                      └─> [cab] (Эмулятор кабинета, опционально)
                                            │
                                            └─> [ph.input] (Фейзер)
                                                  │
                                                  └─> [dA.input, dB.input] (Два дилэя)
                                                        │
                                                        ├─> [master] (На основной выход)
                                                        │
                                                        └─> [revSend] (На посыл реверберации)
```

---

### 7. Приложение А: Эталонная Реализация Маршрутизации V2 (Версия 08ea14d)

Этот раздел документирует правильную, работающую цепочку передачи `instrumentHint`, чтобы избежать будущих ошибок.

1.  **"Заказ" (Блюпринт):**
    В блюпринте (`winter.ts`) в секции `instrumentation` для партии `melody` мы явно указываем, какие инструменты и с каким весом мы хотим использовать.
    ```typescript
    // src/lib/blueprints/blues/winter.ts
    melody: { 
      strategy: 'weighted', 
      v2Options: [ { name: 'telecaster', weight: 0.5 }, { name: 'blackAcoustic', weight: 0.5 } ]
    }
    ```

2.  **"Композитор" (`FractalMusicEngine.evolve`):**
    Метод `evolve` должен иметь следующую **линейную структуру**:
    ```typescript
    // 1. Получить правила от "штурмана"
    const navigationInfo = this.navigator.tick(this.epoch);

    // 2. Выбрать инструменты для ВСЕХ партий
    const v2MelodyHint = this._chooseInstrumentForPart('melody', navigationInfo);
    const accompanimentHint = this._chooseInstrumentForPart('accompaniment', navigationInfo);
    const harmonyHint = this._chooseInstrumentForPart('harmony', navigationInfo);
    // ... и т.д.

    // 3. Собрать ПОЛНЫЙ объект "хинтов"
    const instrumentHints: InstrumentHints = {
        melody: v2MelodyHint,
        accompaniment: accompanimentHint,
        harmony: harmonyHint,
        // ...
    };

    // 4. Сгенерировать партитуру, ПЕРЕДАВАЯ "хинты"
    const { events } = this.generateOneBar(barDuration, navigationInfo, instrumentHints);

    // 5. Вернуть полный результат
    return { events, instrumentHints };
    ```
    Критически важно, что `generateOneBar` **не должен** заново создавать пустой `instrumentHints`.

3.  **"Почтальон" (`ambient.worker.ts`):**
    Воркер должен брать **весь** объект, возвращенный `evolve`, и целиком отправлять его в `payload`.
    ```typescript
    // `scorePayload` содержит и events, и instrumentHints
    const scorePayload = fractalMusicEngine.evolve(this.barDuration, this.barCount);
    // ...
    self.postMessage({ 
        type: 'SCORE_READY', 
        payload: scorePayload // Отправляется ВЕСЬ объект
    });
    ```

4.  **"Исполнитель" (`melody-synth-manager-v2.ts`):**
    Принимая `instrumentHint` (например, `'telecaster'`), его внутренний маршрутизатор направляет задачу на исполнение своему подчиненному — `this.telecasterSampler`.
    ```typescript
    if (instrumentHint === 'telecaster') {
        this.telecasterSampler.schedule(...);
        return; // Важно прервать выполнение, чтобы не уйти на стандартный synth
    }
    // ... остальная логика для синтезатора
    ```

**Вывод:** Соблюдение этой строгой последовательности гарантирует, что "заказ" из блюпринта будет без потерь и искажений доставлен до конечного исполнителя. Любое нарушение этой цепочки приводит к ошибкам маршрутизации.

---
### Приложение Б: Капитальный Ремонт Фабрики (Ноябрь 2024)

Этот раздел документирует масштабные исправления, внесенные в `instrument-factory.ts` и `presets-v2.ts` для достижения стабильности и предсказуемости звука.

#### 1. Диагноз: Выявленные Проблемы

Аудит выявил ряд критических несоответствий между "чертежами" (пресетами) и "сборочной линией" (фабрикой):

*   **Несовместимость Пресетов:** Многие пресеты (особенно `guitar_*` и `organ_*`) имели структуру, которая не соответствовала ожиданиям фабрики. Это приводило к игнорированию параметров, некорректному звучанию или полному отсутствию звука.
*   **Динамическая Пересборка Графа:** Фабрика пыталась динамически пересобирать аудио-граф при смене пресетов, что является источником щелчков, утечек памяти и непредсказуемого поведения.
*   **"Глухая" Огибающая (ADSR):** Предыдущая реализация ADSR не адаптировалась к коротким нотам, что приводило к резким обрывам звука и щелчкам, особенно при игре аккордами.
*   **Отсутствие Централизованного Управления Громкостью:** Не было единого механизма для управления общей громкостью инструмента, что усложняло микширование.

#### 2. Решение: Статический Аудиограф, Адаптивный ADSR и Управление Громкостью

Для устранения этих проблем была внедрена новая, более надежная архитектура:

*   **Статический Аудиограф и "Умный Байпас"**: Для каждого типа инструмента (`synth`, `guitar`) аудио-цепочка со всеми возможными эффектами создается **один раз** при инициализации и больше никогда не изменяется. Включение/выключение эффектов теперь управляется через `GainNode` ("байпас"), что полностью исключает щелчки.
*   **Адаптивная Огибающая (`AdaptiveADSR`)**: Внедрен новый класс-контроллер, который "умно" управляет ADSR. Он анализирует, в какой фазе находится нота в момент ее отпускания, и плавно завершает ее, даже если она была очень короткой. Это полностью решает проблему обрывающихся аккордов и щелчков.
*   **Централизованное Управление Громкостью**: Внедрена двухуровневая система:
    1.  `instrumentGain`: Базовая громкость, устанавливаемая из пресета.
    2.  `expressionGain`: Динамический модификатор для управления экспрессией в реальном времени.

#### 3. Текущее Состояние: Техническая Спецификация (Золотой Стандарт)

1.  **Единый Источник Правды:** `presets-v2.ts` является единственным источником правды для тембров. Все параметры, включая состояние `on/off` для эффектов, должны быть определены там.
2.  **Неизменяемый Граф:** `instrument-factory.ts` создает статическую, максимально полную цепочку эффектов при инициализации. Динамические изменения во время работы происходят только на уровне `AudioParam` (например, `gain.value`, `frequency.value`), но не на уровне `connect`/`disconnect`.
3.  **Полная Совместимость Пресетов:** Все пресеты в `presets-v2.ts` теперь на 100% совместимы со структурой, ожидаемой фабрикой. Поле `type` (`'synth'` или `'guitar'`) является ключевым и определяет, какая сборочная линия будет использована.
4.  **Реализация Органа:** В фабрику добавлена полноценная "сборочная линия" для инструментов типа `organ` на основе пула голосов, что обеспечивает корректную полифонию и обработку ADSR.

Эталонная версия фабрики находится в коммите, следующем за **Планом 1255**.

### Приложение В: Деконструкция Барабанной Логики (Случай с 'Substituted & Blocked')

Этот раздел служит документированным "постмортемом" одной из самых сложных и поучительных проблем, с которыми мы столкнулись: почему замененный по правилу `substitute` инструмент (`drum_brush1`) блокировался фильтром.

#### 1. Проблема: Парадокс "Разрешено, но Запрещено"

Мы наблюдали следующую аномалию в логах:
1.  **"Дирижер" (`generateDrumEvents`)** корректно применял правило `substitute` и готовил набор инструментов, где `hihat` должен был играться сэмплом `drum_brush1`.
2.  **"Композитор" (`createDrumAxiom`)** получал этот набор, видел партию для `drum_hihat_closed`, понимал, что его нужно заменить на `drum_brush1`, и **успешно генерировал событие** `{ type: 'drum_brush1', ... }`. Лог `[DrumAxiom] ... Instruments: kick, snare, brush1` это подтверждал.
3.  **И сразу после этого** мы видели лог `[DrumFilter] 2. BLOCKED: 'drum_brush1'`, приходивший из `fractal-music-engine.ts`.

Это означало, что в системе существовало **два фильтра**. Первый, правильный, находился в `createDrumAxiom` и корректно выполнял замену. Второй, избыточный и ошибочный, находился в `generateDrumEvents` и неправомерно блокировал уже исправленную партитуру.

#### 2. Неправильная Архитектура: "Двойной Контроль"

```
[1. `generateDrumEvents` (Дирижер)]
 │
 ├─ 1. Собирает "Оркестр" (`finalKit`) с правилом "играть щетками вместо хэтов".
 │
 ├─ 2. Вызывает `createDrumAxiom`, передавая ему этот "Оркестр".
 │  │
 │  └─ [2. `createDrumAxiom` (Композитор + Умный Фильтр)]
 │     │
 │     ├─ а. Пишет "Партитуру" (рифф), где есть ноты для `drum_hihat_closed`.
 │     │
 │     └─ б. **УМНЫЙ ФИЛЬТР:** Сверяет партитуру с "Оркестром".
 │        │  - Видит ноту для `drum_hihat_closed`.
 │        │  - Видит правило `substitute` -> `drum_brush1`.
 │        │  - **Заменяет и пропускает** событие как `{ type: 'drum_brush1', ... }`.
 │        │
 │     └─ в. Возвращает ИДЕАЛЬНУЮ, отфильтрованную партитуру.
 │
 ├─ 3. [!!! ОШИБКА !!!] Получив идеальную партитуру, запускает
 │     **ВТОРОЙ, ИЗБЫТОЧНЫЙ ФИЛЬТР**.
 │     │
 │     └─ а. Берет событие `{ type: 'drum_brush1', ... }`.
 │     │
 │     └─ б. Пытается проверить его по своей запутанной логике,
 │           сравнивая категорию исходного риффа (`hihat`)
 │           с категорией, где щетки лежат в ките (`snare`).
 │           Из-за этого конфликта **блокирует** событие.
 │
 └─ 4. Возвращает испорченную, пустую партитуру.
```

#### 3. Корень Зла: Избыточность и Нарушение Принципа Единственной Ответственности

Проблема была не в логике фильтрации, а в ее **дублировании**. Метод `generateDrumEvents` брал на себя чужую роль, перепроверяя уже готовую работу, причем делая это с ошибками.

#### 4. Финальная, Правильная Архитектура: "Доверяй, но не перепроверяй"

После "увольнения двойника" (План 1207), цепочка стала простой и надежной:

```
[1. `generateDrumEvents` (Дирижер / Сборщик Оркестра)]
 │
 ├─ 1. Собирает "Оркестр" (`finalKit`) с правилом "играть щетками вместо хэтов".
 │
 ├─ 2. Вызывает `createDrumAxiom`, передавая ему этот "Оркестр".
 │  │
 │  └─ [2. `createDrumAxiom` (Композитор + Единственный Фильтр)]
 │     │
 │     ├─ а. Пишет "Партитуру".
 │     │
 │     └─ б. **ЕДИНСТВЕННЫЙ ФИЛЬТР:** Сверяет, заменяет и пропускает события.
 │     │
 │     └─ в. Возвращает финальную, готовую к исполнению партитуру.
 │
 └─ 3. **Немедленно возвращает** полученную партитуру, не внося в нее никаких изменений.
```

**Вывод:** Этот случай стал ключевым уроком о важности принципа единственной ответственности (Single Responsibility Principle). `generateDrumEvents` должен только готовить данные, а `createDrumAxiom` — только их обрабатывать. Любое смешение этих ролей порождает хаос.

---
### Приложение Г: Деконструкция Басового Движка V2

Этот раздел описывает архитектуру и возможности басового движка, реализованного в `src/lib/instrument-factory.ts` и управляемого пресетами из `src/lib/bass-presets.ts`.

#### 1. Обзор Архитектуры

Басовый движок V2 построен на принципе **статического аудио-графа**. Это означает, что вся цепочка обработки звука создается один раз при инициализации и никогда не изменяется динамически. Это обеспечивает максимальную производительность и стабильность, исключая щелчки и утечки памяти.

*   **Полифония:** Управляется через `Map` активных голосов, где ключ — MIDI-нота.
*   **Огибающая:** Используется умный `AdaptiveADSR` контроллер, который корректно обрабатывает даже очень короткие ноты, предотвращая щелчки при затухании.
*   **Расположение:** Весь код находится в `instrument-factory.ts` (функция `buildBassEngine`), а все пресеты — в `bass-presets.ts`.

#### 2. Цепочка Эффектов

Сигнал от осцилляторов проходит следующую цепочку обработки:

```
[bassSum] (Сумма осцилляторов и саб-баса)
    │
    └─> [inputComp] (Легкий компрессор для выравнивания)
          │
          ├─> [driveMix] (Параллельный блок дисторшна)
          │     ├─> [driveDry] (Чистый сигнал)
          │     └─> [driveWet] -> [shaper] -> [driveTone] (Сигнал с перегрузом)
          │
          └─> [masterFilter] (Основной фильтр, управляемый LFO)
                │
                └─> [EQ: low, mid, high] (Трехполосный эквалайзер)
                      │
                      └─> [outputComp] (Финальный компрессор для плотности)
                            │
                            └─> [chorusMerge] (Параллельный хорус)
                                  │
                                  └─> [delayMerge] (Параллельный дилэй)
                                        │
                                        └─> [expressionGain] -> [instrumentGain] -> [master]
                                              │                       │                │
                                              └───────────────────────┴────────────────┴──> [output]
                                              │
                                              └─> [reverbWet] -> [reverb] -> [master] (Посыл на реверберацию)
```

#### 3. Спецификация Пресета (`BassPreset`)

Объект пресета позволяет детально настроить каждый аспект звучания:

*   `osc` и `sub`: Настройка осцилляторов (форма волны, октава, детюн, громкость).
*   `adsr`: Основная огибающая громкости.
*   `filter`: Главный фильтр (частота, резонанс, тип).
*   `filterEnv`: Огибающая фильтра для создания динамического тембра ("вау", "плак").
*   `drive`: Секция перегруза (tube, fuzz, soft clip).
*   `comp`: Финальный компрессор для "склеивания" звука.
*   `eq`: Трехполосный эквалайзер для точной настройки частот.
*   `stringNoise`: Добавление реалистичного шума атаки (finger, pick, slap).
*   `chorus`, `delay`, `reverbMix`: Секция пространственных эффектов.

#### 4. Каталог Пресетов

Ниже приведен полный список доступных басовых пресетов и их характер.

| ID Пресета | Описание |
| :--- | :--- |
| `bass_jazz_warm` | Тёплый, округлый, в стиле контрабаса. |
| `bass_jazz_fretless` | Выразительный "mwah" звук безладового баса. |
| `bass_blues` | Классический блюзовый бас с легким "песком". |
| `bass_ambient` | Глубокий, медленный, атмосферный саб-бас. |
| `bass_ambient_dark` | Очень низкий, гудящий дрон для мрачных пейзажей. |
| `bass_trance` | Пробивной, "качающий" бас для транса. |
| `bass_trance_acid` | Резонансный, "квакающий" эйсид-бас. |
| `bass_reggae` | Глубокий, округлый и "дабовый" бас. |
| `bass_dub` | Более тяжелый даб-бас с выраженным дилэем. |
| `bass_house` | Плотный, современный бас в стиле 808 для хауса. |
| `bass_808` | Классический 808 саб-бас с длинным затуханием. |
| `bass_deep_house` | Теплый и "грувовый" бас для дип-хауса. |
| `bass_rock_pick` | Агрессивный, медиаторный бас для рока. |
| `bass_slap` | Яркий, перкуссионный слэповый бас для фанка. |

---
### Приложение Д: Архитектура Производительных Сэмплеров (Урок об Утечках)

Этот раздел документирует критически важный урок, извлеченный в ходе отладки проблем с производительностью. Он описывает "правильный" и "неправильный" паттерны работы с одноразовыми аудио-сэмплами, чтобы гарантировать стабильность приложения.

#### 1. Проблема: "Тихая" Утечка Аудио-Узлов

В ходе разработки мы столкнулись с проблемой, когда приложение работало стабильно в течение 30-40 секунд, а затем начинало "заикаться", хрипеть и в итоге "падало", особенно на мобильных устройствах.

**Причина:** Некорректная работа с аудио-графом. Для каждой проигрываемой ноты сэмплера создавался не только `AudioBufferSourceNode` (который автоматически уничтожается после проигрывания), но и `GainNode` для управления громкостью. Этот `GainNode` **никогда не удалялся** из аудио-графа.

**Неправильный (ошибочный) паттерн:**

```typescript
// Внутри метода schedule() или play() сэмплера

function playLeakyNote(buffer, time, velocity) {
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    // !!! ОШИБКА: GainNode создается, но никогда не уничтожается
    const gainNode = audioContext.createGain(); 
    gainNode.gain.setValueAtTime(velocity, time);

    source.connect(gainNode);
    gainNode.connect(this.preamp); // preamp - это общий выход сэмплера

    source.start(time);

    // Узел gainNode остается в графе навсегда, даже когда звук отыграл.
}
```

Сотни таких "осиротевших" узлов быстро перегружали основной поток, вызывая сбои.

#### 2. Решение: Паттерн "Сыграл и Умер" с `onended`

Правильная архитектура заключается в том, чтобы гарантировать удаление **всех** временных узлов после того, как они выполнили свою задачу.

**Правильный (производительный) паттерн:**

```typescript
// Внутри метода schedule() или play() сэмплера

function playStableNote(buffer, time, velocity) {
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(velocity, time);

    source.connect(gainNode);
    gainNode.connect(this.preamp);

    source.start(time);

    // !!! РЕШЕНИЕ: Добавляем обработчик, который сработает ПОСЛЕ проигрывания
    source.onended = () => {
        // Отсоединяем узел громкости от аудио-графа.
        // Теперь сборщик мусора JavaScript может его безопасно удалить.
        gainNode.disconnect(); 
    };
}
```

**Вывод:**

Этот паттерн — "золотой стандарт" для работы с одноразовыми звуками в Web Audio API. Он гарантирует, что аудио-граф остается чистым, а приложение — производительным и стабильным в течение неограниченного времени. Любой другой подход к работе с динамически создаваемыми узлами должен рассматриваться как потенциальная утечка ресурсов.
