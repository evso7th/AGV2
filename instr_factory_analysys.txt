Код в целом рабочий, но в “финальной” фабрике есть несколько мест, которые **могут снова дать “нет звука/не работает компрессор/всё дублируется”** — особенно в `guitar` и немного в `synth`. Ниже — точечный чек-лист и минимальные правки.

## 1) Synth: критично — `use2pole` “застыл” и не обновляется при setPreset
Вы вычисляете:

```ts
const use2pole = (currentPreset.lpf?.mode !== '24dB');
if (!use2pole) { filt.connect(filt2); }
const lastFilter = use2pole ? filt : filt2;
```

А потом в `updateNodesFromPreset()` используете **тот же `use2pole`**, но он уже не меняется при `setPreset()`.  
Итог: переключение 12/24dB режимов через пресет работать не будет корректно.

**Как исправить (минимально):**
- Сделайте `let use2pole = true;`
- В `updateNodesFromPreset(p)` пересчитывайте `use2pole = (p.lpf?.mode !== '24dB')`
- И важно: если меняете режим, нужно пересобрать соединения фильтров. Сейчас соединение делается один раз.

Простой патч:

```ts
let use2pole = true;

const rebuildFilterRouting = () => {
  try { filt.disconnect(); } catch {}
  try { filt2.disconnect(); } catch {}

  if (!use2pole) {
    filt.connect(filt2);
  }
};

const updateNodesFromPreset = (p:any) => {
  use2pole = (p.lpf?.mode !== '24dB');
  rebuildFilterRouting();
  // дальше параметры filt/filt2 как у вас...
};
```

И `lastFilter` тоже должен зависеть от текущего `use2pole`. Самый простой путь: держать `let lastFilter: AudioNode = filt;` и обновлять его при смене режима.

## 2) Synth: FX on/off не пересобираются при setPreset
Вы один раз решаете:

```ts
if (currentPreset.chorus?.on) { ... }
if (currentPreset.delay?.on) { ... }
```

Но в `setPreset()` вы не переподключаете цепочку. Поэтому если вы включили/выключили `chorus.on` или `delay.on` новым пресетом — ничего не изменится.

**Минимальная рекомендация:** либо всегда держать chorus/delay подключенными и управлять `mix` (байпас через wet gain), либо пересобирать routing при setPreset.

Если хотите минимум вмешательства: делайте chorus/delay всегда в цепи, а при `on=false` ставьте `mix=0`.

## 3) Guitar: критично — `connectFxChain()` может наделать дублей
Сейчас `connectFxChain()`:

- делает `lastInChain.disconnect()` (только у `lastInChain`)
- но **не отключает** `ph.output -> dA.input`, `dA.output -> dB_node.input`, `fxChain -> guitarOut` при повторных вызовах  
- а повторный вызов у вас возможен (например, когда загрузится cab IR и вы поменяете `lastInChain = cab`, или если вы позже решите вызывать connectFxChain снова)

Также: если IR загрузился, вы делаете:

```ts
postLPF.connect(cab);
lastInChain = cab;
```

Но **postLPF уже был подключен куда-то** (как минимум в ph.input через initial connectFxChain). В итоге postLPF может остаться подключенным и к ph.input и к cab (две параллельные ветки) — это опять дублирование/фаза/громкость/каша.

**Правильно:** при появлении cab нужно:
1) `postLPF.disconnect()` (от старого пути)
2) `postLPF.connect(cab)`
3) `cab.connect(ph.input)` (и только так)

А `connectFxChain` лучше не использовать или сделать его “чистым” (с полным disconnect всех участков).

Минимальный фикс загрузки cab:

```ts
if (cabinetIRUrl) {
  loadIR(ctx, cabinetIRUrl).then(buffer => {
    if (buffer) {
      cab.buffer = buffer;

      try { postLPF.disconnect(); } catch {}
      postLPF.connect(cab);

      try { cab.disconnect(); } catch {}
      cab.connect(ph.input);

      lastInChain = cab;
    }
  });
} else {
  postLPF.connect(ph.input);
}
```

И тогда `connectFxChain()` вообще можно упростить до одного раза, без переподключений `lastInChain`.

## 4) Guitar: потенциальный крэш если нет `osc` в пресете
В `noteOn`:

```ts
const { osc, adsr } = currentPreset;
const oscMain = createPulseOsc(ctx, f, osc.width); // если osc undefined -> ошибка
```

Если в пресете не задан `osc`, будет runtime error и звук пропадёт.

**Фикс:**
```ts
const oscP = currentPreset.osc ?? {};
const oscMain = createPulseOsc(ctx, f, oscP.width);
...
gMain.gain.value = oscP.mainGain ?? 0.85;
```

Аналогично для `drive.amount` в `updateGuitarNodes`:
```ts
shaper.curve = (p.drive?.type === 'muff')
  ? makeMuff(p.drive?.amount ?? 0.65)
  : makeSoftClip(p.drive?.amount ?? 0.2);
```

## 5) Master reverb: convolver не подключён к master (если вы хотите общий ревер)
Сейчас вы делаете send в reverb, но **reverb сам никуда не подключён**, кроме как через `revSend.connect(reverb)`.

Нужно еще:
```ts
reverb.connect(master);
```

Иначе даже при `revSend` — ничего не услышите от ревера.

В synth вы делаете `revSend.connect(reverb)`, в guitar тоже — но `reverb` не подключен к `master`. В вашем старом коде это было.

**Добавьте один раз после создания reverb:**
```ts
reverb.connect(master);
```

(или `reverb.connect(master)` только если `reverb.buffer` есть)

## 6) Общая мелочь: `api.connect()` сейчас бесполезен/опасен
Вы уже в конце делаете:
```ts
master.connect(output || ctx.destination);
```
и при этом `api.connect()` тоже подключает `master` куда-то ещё. Можно получить двойное подключение.

Либо уберите финальный `master.connect(...)` и используйте только `api.connect()`, либо `api.connect()` пусть не делает ничего/или делает disconnect+connect.

---

# Минимальный набор правок “чтобы было железобетонно”
1) Сразу после загрузки plateIR (или даже без него):
```ts
reverb.connect(master);
```

2) В `guitar.noteOn` использовать безопасный `oscP = currentPreset.osc ?? {}`.

3) При загрузке cab IR: `postLPF.disconnect()` перед `postLPF.connect(cab)` и `cab.connect(ph.input)`.

4) В `synth`: пересчитывать `use2pole` при `setPreset`, и пересобирать routing фильтра (или хотя бы корректно выбирать `lastFilter`).

---

Если хотите, я могу:
- либо дать **короткий diff-патч** прямо по вашему коду (вставками “замени этот блок на этот”),
- либо прислать “финальную” версию, где synth/guitar имеют **правильный байпас эффектов** без переподключений (самый стабильный вариант).

Скажите: вы хотите, чтобы `chorus.on`/`delay.on` переключались на лету через `setPreset`, или достаточно только параметров?
