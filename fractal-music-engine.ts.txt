import type { FractalEvent, Mood, Genre } from '@/types/fractal';
import { MelancholicMinorK } from './resonance-matrices';

// === ТИПЫ ===
export type Branch = {
  id: string;
  events: FractalEvent[];
  weight: number;
  age: number;
  technique: 'pluck' | 'ghost' | 'slap';
};

// === КОНФИГУРАЦИЯ ===
interface EngineConfig {
  mood: Mood;      // 'melancholic', 'epic', 'dreamy', 'dark'
  genre: Genre;    // 'trance', 'ambient', 'progressive'
  tempo: number;   // BPM
  seed?: number;
}

// === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===
function seededRandom(seed: number) {
  let state = seed;
  return {
    next: () => {
      state = (state * 1664525 + 1013904223) % Math.pow(2, 32);
      return state / Math.pow(2, 32);
    },
    nextInt: (max: number) => Math.floor(this.next() * max)
  };
}

function getScaleForMood(mood: Mood): number[] {
  const E2 = 40; // E2 — реальный бас
  if (mood === 'melancholic') return [E2, E2+2, E2+3, E2+5, E2+7, E2+9, E2+10]; // E Dorian
  return [E2, E2+2, E2+4, E2+5, E2+7, E2+9, E2+11]; // E Major
}

function weightToDynamics(weight: number): 'p' | 'mf' | 'f' {
  if (weight < 0.3) return 'p';
  if (weight < 0.7) return 'mf';
  return 'f';
}

// === ОСНОВНОЙ КЛАСС ===
export class FractalMusicEngine {
  private config: EngineConfig;
  private branches: Branch[] = [];
  private time: number = 0; // ✅ ИНИЦИАЛИЗИРОВАНО!
  private lambda: number;
  private epoch = 0;

  constructor(config: EngineConfig) {
    this.config = config;
    this.lambda = config.mood === 'melancholic' ? 0.25 : 0.15;
    this.initialize();
  }

  private initialize() {
    const seed = this.config.seed ?? Date.now();
    const random = seededRandom(seed);
    const scale = getScaleForMood(this.config.mood);
    const root = scale[random.nextInt(scale.length)];

    // Простой меланхоличный мотив: E2–G2–F#2–E2
    const axiomEvents: FractalEvent[] = [
      { type: 'bass', note: root, duration: 1.5 },
      { type: 'bass', note: root + 3, duration: 0.5 },
      { type: 'bass', note: root + 2, duration: 1.5 },
      { type: 'bass', note: root, duration: 0.5 }
    ];

    this.branches = [{
      id: 'axon',
      events: axiomEvents,
      weight: 1.0,
      age: 0,
      technique: 'pluck'
    }];
  }

  // === ГЕНЕРАЦИЯ УДАРНЫХ (4/4 ПАТТЕРН) ===
  private generateDrumEvents(durationBars: number): FractalEvent[] {
    const events: FractalEvent[] = [];
    const barDuration = 4 * (60 / this.config.tempo); // секунд в такте

    for (let bar = 0; bar < durationBars; bar++) {
      const barStart = this.time + bar * barDuration;
      const beat = 60 / this.config.tempo; // длительность доли

      // Kick на 1 и 3
      events.push({
        type: 'drum_kick',
        note: 36,
        duration: 0.1,
        time: barStart,
        weight: 1.0,
        technique: 'hit',
        dynamics: 'f',
        phrasing: 'staccato'
      });
      events.push({
        type: 'drum_kick',
        note: 36,
        duration: 0.1,
        time: barStart + 2 * beat,
        weight: 1.0,
        technique: 'hit',
        dynamics: 'f',
        phrasing: 'staccato'
      });

      // Snare на 2 и 4
      events.push({
        type: 'drum_snare',
        note: 38,
        duration: 0.1,
        time: barStart + 1 * beat,
        weight: 1.0,
        technique: 'hit',
        dynamics: 'mf',
        phrasing: 'staccato'
      });
      events.push({
        type: 'drum_snare',
        note: 38,
        duration: 0.1,
        time: barStart + 3 * beat,
        weight: 1.0,
        technique: 'hit',
        dynamics: 'mf',
        phrasing: 'staccato'
      });
    }
    return events;
  }

  // === ОСНОВНОЙ МЕТОД ===
  public evolve(): FractalEvent[] {
    const delta = this.getDeltaProfile()(this.time);
    const output: FractalEvent[] = [];

    // 1. Обновление весов по формуле
    this.branches = this.branches.map(branch => {
      const resonanceSum = this.branches.reduce((sum, other) => {
        if (other.id === branch.id) return sum;
        const k = MelancholicMinorK(branch.events[0], other.events[0], {
          mood: this.config.mood,
          delta,
          kickTimes: [], // в реальной версии — заполнить
          snareTimes: [],
          beatPhase: (this.time * this.config.tempo / 60) % 4
        });
        return sum + k * delta;
      }, 0);
      const newWeight = (1 - this.lambda) * branch.weight + resonanceSum;
      return { ...branch, weight: newWeight, age: branch.age + 1 };
    });

    // 2. Смерть слабых ветвей
    this.branches = this.branches.filter(b => b.weight > 0.05);

    // 3. DLA: иногда добавляем ghost notes
    if (Math.random() < 0.4 && this.epoch > 2) {
      const base = this.branches[0];
      if (base) {
        this.branches.push({
          id: `ghost_${Date.now()}`,
          events: [{ ...base.events[1], duration: 0.2 }],
          weight: 0.15,
          age: 0,
          technique: 'ghost'
        });
      }
    }

    // 4. Генерация басовых событий
    this.branches.forEach(branch => {
      branch.events.forEach(event => {
        output.push({
          ...event,
          time: this.time,
          weight: branch.weight,
          technique: branch.technique,
          dynamics: weightToDynamics(branch.weight),
          phrasing: branch.weight > 0.7 ? 'legato' : 'staccato'
        });
        this.time += event.duration * (60 / this.config.tempo);
      });
    });

    // 5. Добавляем ударные (2 такта за вызов)
    const drumEvents = this.generateDrumEvents(2);
    output.push(...drumEvents);

    this.epoch++;
    return output;
  }

  private getDeltaProfile(): (t: number) => number {
    return (t: number) => {
      const phase = (t / 120) % 1;
      if (this.config.mood === 'melancholic') {
        if (phase < 0.4) return 0.3 + phase * 1.5;
        if (phase < 0.7) return 1.0;
        return 1.0 - (phase - 0.7) * 2.3;
      }
      return 0.5;
    };
  }
}